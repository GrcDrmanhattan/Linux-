1 厨师做饭 

2
2
5
6
4
2
4
6
5
2
3
3
3
3
4
6
1
5
1
1
7



#include<bits/stdc++.h>

using namespace std;

class LRU{
 public:
  struct node{
      int k;
      node* left;
      node* right;
      node(int _k){
          k=_k;
          left =right =nullptr;
      }
  };   
    node* head;
    node* tail;
    int n;
    unordered_map<int, node* > hn;
    int res;
    
    LRU(int size){
        n=size;
        res=0;
        head=new node(-1);
        tail=new node(-1);
        head->right = tail;
        tail->left = head;
    }

  void remove(node* p){
      p->left->right = p->right ;
      p->right->left=p->left;
  }
   
    void insert(node* p){
        p->right = head->right;
        p->left = head;
        
        head->right->left=p;
        head->right =p;
    }
    
    void put(int k){
        if(hn.count(k) ==0){
            if(n==hn.size()){
                res += 6;
                auto p=tail->left;
                remove(p);
                hn.erase(p->k);
            }
            res += 15;
            auto p=new node(k);
            insert(p);
            hn[k]=p;
        }
        else{
            res+=15;
            auto p=hn[k];
            remove(p);
            insert(p);
        }
    }
};

int main(){
    LRU* lru=new LRU(3);
    
    int x;
    
    while(1){
        cin>>x;
        if(x == 7){
            cout<<lru->res<<endl;
            break;
        }else{
            
            lru->put(x);
            cout<<"---"<<lru->res<<endl;
        }
        
    }
    
    // cout<<<<endl;
    return 0;
}
//更换6 ，做饭15



-------------------2  不同路径数2


----3   输出 e
char ch[]="abc\0def";
    char *p = ch;
    printf("%c", *p+4);
     
     
  *p 输出a， *p+1 输出b， *p+3输出d，会跳过\0
  
  
     
------4     输出test

void test(char* p){
    p="abc";
}

int main()
{
    char *p="test";
    test(p);
    printf("%s\n", p);
    return 0;
}

-----5       输出20

#define mod(x, y) x%y

int main()
{
    int x=67;
    int y=9;
    printf("%d", mod(x, y+8) * 2);
    return 0;
}


67 % 9+8*2 =  4 + 16 


-----6    

struct stru{
    char c;
    int a;
};

union uni{
  char c;
  int a;
};

int fun(struct stru arr[2]){
    const char *str = "hello";
    char str2[]="he";
    struct stru st={0};
    union uni un = {0};
    
    cout<< sizeof(arr)<<" sizeof arr"<<endl;
    cout<< sizeof(str) <<" sizeof str"<<endl;
    cout<<sizeof(str2)<<" sizeof str2"<<endl;
    cout<<sizeof("hello")<<" sizeof hello"<<endl;
    cout<<sizeof(st)<<" sizeof st"<<endl;
    cout<<sizeof(un)<<" sizeof un"<<endl;
}

int main()
{
    struct stru arr[2];
    fun(arr);
    
    return 0;
}

输出
8 sizeof arr  指针
8 sizeof str 指针
3 sizeof str2  用双引号初始化的，结尾补上\0
6 sizeof hello  结尾\0
8 sizeof st  结构体大小
4 sizeof un  联合体大小



------------ 7

输出  1， 3， 2

int fun(int *p, int v){
    *p=1;
    v=1;
    return *p + v;
}

void caller(int val){
    int ptr=2;
    int ret;
    val=3;
    ret=fun(&ptr, val);
    printf("%d, %d, %d\n" ,ptr, val, ret);
}

int main()
{
    caller(77);
    return 0;
}


------------ 8

void fun(){
    int a[5][2]={
      0,1,2, 3, 4, 5, 6, 7  
    };
    
    cout<<"----"<<endl;
    for(int i=0;i<5;++i){
        for(int j=0;j<2;++j){
            cout<<a[i][j]<<" ";
        }
        cout<<endl;
    }
    cout<<"---"<<endl;
    
    int *p1=a[1];
    int (*p2)[2]=&a[1];
    
    printf("%d\n", *p1); // 2
    printf("%d\n", *p1++); //2
    printf("%d\n", *++p1);// 4
    printf("%d\n", **p2); // 2 
    printf("%d %d %d\n", p2[2][0], p2[2][1], p2[2][2]); // 6 7 0
}
/*
----
0 1 
2 3 
4 5 
6 7 
0 0 
---
*/

int main()
{
    fun();
    return 0;
}


------------9

输出 0 

void fun(){
    int a;
    cout<<a<<endl;
} 

void fun(){
   static int a;
    cout<<a<<endl; // 0
}

int a;
void fun(){
    
    cout<<a<<endl; // 输出0
} 

struct t{
  int a;
  int b;
} t={1};

int main()
{
    printf("%d", t.a/t.b); // float point exception
    return 0;
} 




     
