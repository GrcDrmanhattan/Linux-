--------1  将每个数字的每一位，每次都可以增加1，总共次数最多k次，返回结果最大的数字

// you can use includes, for example:
// #include <algorithm>
// #include<bistd/stdc++.h>
#include<vector>
#include<algorithm>

// you can write to stdout for debugging purposes, e.g.
// cout << "this is a debug message" << endl;

int solution(int N, int K) {
    // write your code in C++14 (g++ 6.2.0)

    // cout<<"123"<<endl;
    vector<int> num;
    while(N){
        auto x=N%10;
        num.push_back(x);
        N/=10;
    }
    reverse(num.begin(), num.end());//512
    // auto tm=K;
    for(auto &x:num){
        // cout<<"---x "<<x<<endl;
        // cout<<"---k "<<K<<endl;
        
        for(int i=9;i>=0;--i){
            if(x + i >= 10) continue;
            if(i <= K && x + i <= 9){
                x+=i;
                // cout<<"--"<<x<<"--"<<i<<endl;
                K-=i;
                break;
            }
        }
    }
    int res=0;
    // reverse(num.begin(), num.end());//215
    for(auto x:num) res = res * 10 + x;
    // cout<<"--res "<<res<<endl;
    
    return res;
}


--------------------  2   两个木棍拼成正方形，返回最大正方形的边长

int solution(int A,int B){
	int i=1,j=3;
	int ans=max(A/4,B/4);
	while(j){
		int lenA=A/i;
		int lenB=B/j;
		ans=max(ans,min(lenA,lenB));
		i++;
		j--; 
	}
	return ans;
} 




3 ---------------   

给个数组A，一个整数x和y，对数组中的元素做变换，
第一种变换是将某个元素变为0，这个变换的cost是x；
第二种是将某个元素乘上-1，这个变换的cost是y；
第三种是不做任何变化。最后要使数组的和小于等于0，求最小的cost


long long sum[100005];
int solution(vector<int> &A,int X,int Y){
	sort(A.begin(),A.end());
	sum[0]=0;
	for(int i=0;i<A.size();i++){
		sum[i+1]=sum[i]+A[i];
	}
	long long ans=1000000005;
	int n=A.size();
	for(int i=0;i<=n;i++){//Y
		int l=0;
		int r=n-i;
		while(l<=r){
			int mid=(l+r)/2;//X
			long long sum1=-(sum[n]-sum[n-i]);
			long long sum2=sum[n-i-mid];
			if(sum1+sum2<=0){
				ans=min(ans,(long long)i*Y+mid*X);
//				cout<<i<<' '<<mid<<endl;
				r=mid-1;
			}else{
				l=mid+1;
			}
		}
	}
	return ans;
} 



