127. 单词接龙

字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：

序列中第一个单词是 beginWord 。
序列中最后一个单词是 endWord 。
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词。
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。

 
示例 1：

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
输出：5
解释：一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog", 返回它的长度 5。
示例 2：

输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
输出：0
解释：endWord "cog" 不在字典中，所以无法进行转换。
 

提示：

1 <= beginWord.length <= 10
endWord.length == beginWord.length
1 <= wordList.length <= 5000
wordList[i].length == beginWord.length
beginWord、endWord 和 wordList[i] 由小写英文字母组成
beginWord != endWord

------------------- 0830  /2021 yxc 

class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> st;
        for(auto x:wordList) st.insert(x);
        unordered_map<string, int> dis;
        dis[beginWord]=0;
        queue<string> q;
        q.push(beginWord);

        while(q.size()){
            auto t=q.front();
            q.pop();

            string r=t;
            for(int i=0;i<t.size();++i){
                t=r;
                for(char j='a';j<='z';++j){
                    t[i]=j;
                    if(st.count(t) && dis.count(t)==0){
                        dis[t]=dis[r]+1;
                        if(t==endWord) return dis[t]+1;
                        q.push(t);
                    }
                }
            }
        }

        return 0;
    }
};


