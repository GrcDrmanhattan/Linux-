139. 单词拆分

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

----------------------- 0317  /2021/  yxc 


// f[i] 集合s[1-i]的所有合法划分方案是否为空
// 将f[i] 划分为，最后一个单词从1到i， 2到i，。。。i到i的集合
// 状态数目On， 状态计算On， 时间On^2
// 每个空隙是否切分，指数级别
// 字符串哈希，这样查找的时间优化为O1


class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        typedef unsigned long long ull;
        unordered_set<ull> hash;
        const int p=131;

        for(auto x:wordDict){ // 将每个单词储存为一个数
            ull h=0;
            for(auto c:x) h= h*p + c;
            hash.insert(h);
        }

        int n=s.size();
        vector<bool> f(n+1);
        f[0]=1;

        s=' ' + s;
        for(int i=0; i< n;++i)
            if(f[i]){ // 如果前i个可以合法，看最后一段是否合法
                ull h=0;
                for(int j=i+1; j<= n;++j){
                    h=h*p+s[j];
                    if(hash.count(h)) f[j]=true;// 前i个合法，并且从i+1开始也合法，则说明前j个合法
                }
            }


        return f[n];

    }
};


