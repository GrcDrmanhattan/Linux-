运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。
当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

 

进阶:

你是否可以在 O(1) 时间复杂度内完成这两种操作？

 

示例:

LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得关键字 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得关键字 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4

###############################3

// class LRUCache 
// {

// public:
//     LRUCache(int capacity) 
//     {
//         this->cp=capacity;
//     }
    
//     int get(int key) 
//     {
//         //取出元素
//         auto it=mp.find(key);
//         if(it==mp.end()) return -1;//不存在返回-1
        
//         //存在，就把元素提前位置
//         pair<int ,int > tmp=*mp[key];//链表的样子

//         ls.erase(mp[key]);//删除原来的位置，重新插入到头部
//         ls.push_front(tmp);

//         mp[key]=ls.begin();//更新哈希的映射
//         return tmp.second;

//     }
    
//     void put(int key, int value) //放入元素
//     {
//         auto it=mp.find(key);
//         if(it==mp.end())//插入的不存在
//         {           
//             if(ls.size()==cp)//满了
//             {
//                 auto lastpair=ls.back();
//                 auto lastkey=lastpair.first;
//                 mp.erase(lastkey);
//                 ls.pop_back();
//                 // ls.push_front(make_pair(key,value));//下面已经添加了，这里就不用添加了
//                 // mp[key]=ls.begin();
//             }
//             ls.push_front(make_pair(key,value));
//             mp[key]=ls.begin();
//         }
//         else//存在就更新
//         {
//             ls.erase(mp[key]);
//             ls.push_front(make_pair(key,value));
//             mp[key]=ls.begin();
//         }

//     }

// private:
//     int cp;
//     list<pair<int ,int >> ls;//双向链表,存缓存数据
//     unordered_map<int ,list<pair<int ,int>>::iterator> mp;//哈希表，映射

// };


/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */


//0812 练习


class LRUCache
{
private:
    int cp;
    list<pair<int,int>> ls;//双向链表 stl
    unordered_map<int,list<pair<int,int>>::iterator> mp;//迭代器

public:
    LRUCache(int capacity)
    {
        this->cp=capacity;//箭头
    }

    int get(int key)//访问元素
    {
        if(mp.find(key)!=mp.end())//找到元素
        {
            auto tmp=*mp[key];

            ls.erase(mp[key]);//删除原来的
            ls.push_front(tmp);//放入第一个，提前到队首

            mp[key]=ls.begin();//更新map的位置
            return tmp.second;
        }
        else
        {
            return -1;
        }

    }

    void put(int key, int value)
    {
        if(mp.find(key)!=mp.end())//插入的元素，已经有了，需要更新
        {
            auto tmp=*mp[key];
            tmp.second=value;

            ls.erase(mp[key]);
            ls.push_front(tmp);
            // ls.push_front(make_pair(key,value));这个更简洁
            mp[key]=ls.begin();

        }
        else//插入的原来不存在，就插入
        {
            if(ls.size()==cp)
            {
                //删除最后一个节点
                auto lastpair=ls.back();
                auto lastkey=lastpair.first;
                ls.pop_back();
                mp.erase(lastkey);

                ls.push_front(make_pair(key,value));
                mp[key]=ls.begin();
            }
            else
            {
                ls.push_front(make_pair(key,value));
                mp[key]=ls.begin();
            }
            
        }

    }
};
