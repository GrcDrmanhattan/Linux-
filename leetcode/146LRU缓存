运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。

获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。



##############3



class LRUCache 
{
public:

    LRUCache(int capacity) 
    {
        this->cp=capacity;
    }
    
    int get(int key) 
    {
        //取出元素，先查找是否存在
        auto it=mp.find(key);//在哈希表查找是否存在
        if(it==mp.end()) return -1;//如果到结尾了，是不存在返回-1
        
        //存在，就访问把元素提前位置
        pair<int ,int > tmp=*mp[key];//链表的样子
        ls.erase(mp[key]);//删除原来的位置，重新插入到头部
        ls.push_front(tmp);
        mp[key]=ls.begin();//更新哈希的映射
        return tmp.second;

    }
    
    void put(int key, int value) //放入元素
    {
        auto it=mp.find(key);
        if(it==mp.end())//插入的不存在
        {
            
            if(ls.size()==cp)//满了
            {
                auto lastpair=ls.back();
                auto lastkey=lastpair.first;
                mp.erase(lastkey);//哈希表删除2
                ls.pop_back();//双向链表也删除
                // ls.push_front(make_pair(key,value));//下面已经添加了，这里就不用添加了
                //mp[key]=ls.begin();
            }
            ls.push_front(make_pair(key,value));
            mp[key]=ls.begin();
        }
        else//存在就更新
        {
            ls.erase(mp[key]);
            ls.push_front(make_pair(key,value));
            mp[key]=ls.begin();
        }

    }

private:
    int cp;
    list<pair<int ,int >> ls;//双向链表,存缓存数据
    unordered_map<int ,list<pair<int ,int>>::iterator> mp;//哈希表，映射

};



/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */

