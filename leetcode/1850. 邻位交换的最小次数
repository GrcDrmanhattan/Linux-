1850. 邻位交换的最小次数


给你一个表示大整数的字符串 num ，和一个整数 k 。

如果某个整数是 num 中各位数字的一个 排列 且它的 值大于 num ，则称这个整数为 妙数 。可能存在很多妙数，但是只需要关注 值最小 的那些。

例如，num = "5489355142" ：
第 1 个最小妙数是 "5489355214"
第 2 个最小妙数是 "5489355241"
第 3 个最小妙数是 "5489355412"
第 4 个最小妙数是 "5489355421"
返回要得到第 k 个 最小妙数 需要对 num 执行的 相邻位数字交换的最小次数 。

测试用例是按存在第 k 个最小妙数而生成的。

 

示例 1：

输入：num = "5489355142", k = 4
输出：2
解释：第 4 个最小妙数是 "5489355421" ，要想得到这个数字：
- 交换下标 7 和下标 8 对应的位："5489355142" -> "5489355412"
- 交换下标 8 和下标 9 对应的位："5489355412" -> "5489355421"
示例 2：

输入：num = "11112", k = 4
输出：4
解释：第 4 个最小妙数是 "21111" ，要想得到这个数字：
- 交换下标 3 和下标 4 对应的位："11112" -> "11121"
- 交换下标 2 和下标 3 对应的位："11121" -> "11211"
- 交换下标 1 和下标 2 对应的位："11211" -> "12111"
- 交换下标 0 和下标 1 对应的位："12111" -> "21111"
示例 3：

输入：num = "00123", k = 1
输出：1
解释：第 1 个最小妙数是 "00132" ，要想得到这个数字：
- 交换下标 3 和下标 4 对应的位："00123" -> "00132"
 

提示：

2 <= num.length <= 1000
1 <= k <= 1000
num 仅由数字组成



---------------------- 0504 / 2021/  yxc 


// 奇妙数是第下k个下一个排列
// 逆序对


class Solution {
public:
    int getMinSwaps(string num, int k) {
        string b=num;
        while(k--) next_permutation(b.begin(), b.end());

        int n=num.size();
        vector<int> c(n); // c存储的是num的元素在b的下标
        vector<int> cnt(10, 0);

        for(int i=0;i<n;++i){
            int x=num[i]-'0';
            cnt[x]++;
            int y=cnt[x];

            for(int j=0;j<n;++j){
                if(b[j] -'0'== x && --y == 0){
                    c[i]=j;
                    break;
                }
            }
        }

        int res=0;
        for(int i=0;i<n;++i){
            for(int j=i+1;j<n;++j){
                if(c[i] > c[j]) res++;
            }
        }

        return res;
    }
};



----------------------- 

class Solution {
public:
    int getMinSwaps(string num, int k) {
        string b=num;
        while(k--) next_permutation(b.begin(), b.end());

        int n=num.size();
        vector<int> cnt(10 , 0);
        vector<int> c(n);

        for(int i=0;i<n;++i){ //枚举num
            int x=num[i]-'0';
            cnt[x]++;
            int y=cnt[x];

            for(int j=0;j<n;++j){ // 枚举b字符串
                if(b[j]-'0' == x && --y == 0){
                    c[i]=j;
                    break;
                }
            }
        }

        int res=0;
        for(int i=0;i<n;++i){
            for(int j=i+1;j<n;++j){
                if(c[i] > c[j]) res++;
            }
        }

        return res;
    }
};



-------------------  
class Solution {
public:
    int getMinSwaps(string num, int k) {
        int n=num.size();
        int res=0;
        vector<int> cnt(10, 0);
        vector<int> c(n);

        string b=num;
        while(k--) next_permutation(b.begin(), b.end());

        for(int i=0;i<n;++i){
            int x=num[i]-'0';
            cnt[x]++;
            int y=cnt[x];

            for(int j=0;j<n;++j){
                if(b[j] - '0' == x && y-- == 1){ // 或者y-- == 1， 假如y=4，则要找到出现次数是第四个的字符，y--是先拿y比较然后减少，所以是4， 3， 2，1， 减到1是正好第四个，
                // --y是3，2，1，0 ，减到0是第四个，因为要先减少1再比较
                    c[i]=j;
                    break;
                }
            }

        }

        for(int i=0;i<n;++i){
            for(int  j=i+1;j<n;++j)
                if(c[i] > c[j]) res++;
        }

        return res;
    }
};

