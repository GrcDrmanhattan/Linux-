

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

 

示例：

给你这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5





###############################################
/**
 * Definition for singly-linked list.
 * struct ListNode 
 {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
// class Solution 
// {
// public:
//     ListNode* reverseKGroup(ListNode* head, int k) 
//     {
//         if(!head) return head;
//         ListNode* p=head;
//         int cnt=0;
        
//         while(p)
//         {
//             cnt++;
//             p=p->next;
//             if(cnt==k) break;
            
//         }

//         if(cnt==k)
//         {
//             ListNode* before=head;
//             ListNode* tail=head;
//             ListNode* tmp=head->next;
//             while(--cnt)//只能--cnt，不能cnt--
//             {
                
//                 head=tmp;
//                 tmp=tmp->next;
//                 head->next=before;
//                 before=head;
//             }

//             tail->next=reverseKGroup(p,k);
//             return head;
//         }

//         return head;
//     }
// };


//0813 题解lbldong，通俗易懂


class Solution
{
public:
    ListNode* reverseKGroup(ListNode* head, int k) 
    {
        if(head==NULL) return head;
        ListNode* a=head;
        ListNode* b=head;
        

        for(int i=0;i<k;++i)
        {
            if(b==NULL) return head;
            b=b->next;
        }

        ListNode* newhead=helper(a,b);//反转后，a在尾部

        a->next=reverseKGroup(b,k);//

        return newhead;
    }

    //反转[a,b)之间的链表
    ListNode* helper(ListNode* a,ListNode* b)
    {
        //pre->cur->nxt
        ListNode* pre=NULL;
        ListNode* cur=a;
        ListNode* nxt=a;

        while(cur!=b)
        {
            nxt=cur->next;
            cur->next=pre;//指针反转，指向前一个
            pre=cur;
            cur=nxt;
        }

        return pre;
    }

};
