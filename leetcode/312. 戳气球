312. 戳气球

有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。

现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。
如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。

求所能获得硬币的最大数量。

 

示例 1：
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
示例 2：

输入：nums = [1,5]
输出：10
 

提示：

n == nums.length
1 <= n <= 500
0 <= nums[i] <= 100



-------------------------------   0411 / 2021/  yxc 


// 状态数On^2, 每次On，时间On^3
// 简单的区间dp
// f[i][j] 表示区间i+1，j-1之间全部戳破的方案数的硬币最大



class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n=nums.size();
        vector<int> a(n+2, 1);//0, 1, ...n, n+1, 补上左右两个边界
        for(int i=1;i<=n;++i) a[i] = nums[i-1];

        vector<vector<int>> f(n+2, vector<int>(n+2));

        for(int len =3 ;len <= n+2; ++len) // 区间长度
            for(int i=0; i+len -1 <= n+1; ++i){ // 左端点
                int j=i+len -1 ;  // 右端点
                for(int k=i+1; k< j;++k)
                    f[i][j]=max(f[i][j], f[i][k] + f[k][j] + a[i] * a[j] * a[k]);
            }

        return f[0][n+1];
    }
};



----------------------------------  0725  /2021 


class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n=nums.size();
        vector<int> s(n+2,1);
        for(int i=1;i<=n;++i) s[i]=nums[i-1];

        vector<vector<int>> f(n+2, vector<int>(n+2));

        for(int len=3;len<=n+2;++len){
            for(int i=0;i+len-1<= n+1;++i){
                int j=i+len-1;
                for(int k=i+1;k<j;++k){
                    f[i][j]=max(f[i][j], f[i][k] + f[k][j] + s[i]*s[j]*s[k]);
                }
            }
        }

        return f[0][n+1];
    }
};




------------------------ 0808  /2021 


class Solution {
public:
    int maxCoins(vector<int>& nums) {
        const int n=nums.size();
        vector<int> s(n+2, 1);

        for(int i=1;i<=n;++i) s[i]=nums[i-1];

        vector<vector<int>> f(n+2,vector<int>(n+2));
        for(int len = 3; len<=n+2;++len){
            for(int i=0;i+len-1<=n+1;++i){
                int j=i+len-1;
                for(int k=i+1;k<j;++k) // 枚举k最后一次打气球的位置
                    f[i][j]=max(f[i][j] , f[i][k] + f[k][j] + s[i]*s[j]*s[k]);
            }
        }

        return f[0][n+1];
    }
};


