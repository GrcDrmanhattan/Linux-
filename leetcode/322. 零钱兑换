322. 零钱兑换


给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

 

示例 1：

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
示例 2：

输入：coins = [2], amount = 3
输出：-1
示例 3：

输入：coins = [1], amount = 0
输出：0
示例 4：

输入：coins = [1], amount = 1
输出：1
示例 5：

输入：coins = [1], amount = 2
输出：2
 

提示：

1 <= coins.length <= 12
1 <= coins[i] <= 231 - 1
0 <= amount <= 104

------------------------ 0312 / 2021/  yxc 




时间复杂度分析：令 n 表示硬币种数，m 表示总价钱，则总共两层循环，所以时间复杂度是 O(nm)


// 给n个物品，每个价值是1，体积是面额，装满体积m（凑够总金额）的最少方案
// 转换完全背包
// 用金额凑总金额，相当于凑满体积，




class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> f(amount + 1, 1e8);
        f[0]=0;

        for(auto v:coins)
        {
            for(int j=v; j<= amount;++j)
                f[j]=min(f[j], f[j-v]+1);
        }

        if(f[amount]==1e8) return -1;
        return f[amount];
    }

};


------------------ 0410 / 2021/  



class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> f(amount + 1, 1e8);
        f[0]=0; // 只有凑0的时候才有解，其余的初始化为1e8
       

        for(auto x:coins){
            for(int j=x ; j<= amount;++j){
                f[j] = min(f[j], f[j-x] + 1);
            }
        }

        if(f[amount]==1e8) return -1;
        else return f[amount];
    }
};


---------------- 0726  /2021  

class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> f(amount+1, 1e8);
        f[0]=0;

        for(auto x:coins){
            for(int j=x;j<=amount;++j)
                f[j]=min(f[j], f[j-x]+1);
        }
        
        if(f[amount]==1e8) return -1;
        return f[amount];
    }
};

--------------------- 0808  /2021  

class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> f(amount+1, 1e8);
        f[0]=0;

        for(auto x:coins){
            for(int j=x;j<=amount;++j)
                f[j]=min(f[j], f[j-x]+1);
        }
        
        if(f[amount]==1e8) return -1;
        return f[amount];
    }
};


