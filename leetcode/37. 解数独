37. 解数独
编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

 

示例：


输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],
["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],
[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]

输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],
["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],
["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：


 

提示：

board.length == 9
board[i].length == 9
board[i][j] 是一位数字或者 '.'
题目数据 保证 输入数独仅有一个解

---------------------- 0418 / /2021/  yxc  

class Solution {
public:
    int ones[1<<9];
    int map[1<<9];
    int row[9];
    int col[9];
    int cell[3][3];
    
    void init(){
        for(int i=0;i<9;++i) row[i]=col[i]=(1<<9)-1;
        for(int i=0;i<3;++i)
            for(int j=0;j<3;++j)
                cell[i][j]=(1<<9)-1;

    }

    int lowbit(int x )
    {
        return x & -x;
    }

    int get(int x, int y){
        return row[x] & col[y] & cell[x/3][y/3];
    }

    void solveSudoku(vector<vector<char>>& board) {
        for(int i=0;i< 1<<9;++i)
            for(int j=0;j<9;++j)
                ones[i] += i>>j&1;

        for(int i=0;i<9;++i) map[1<<i]=i;

        init();

        int cnt=0;
        for(int i=0;i<9;++i)
            for(int j=0;j<9;++j)
            {
                if(board[i][j] != '.'){

                    int t=board[i][j]-'1';
                    row[i] -= 1<<t;
                    col[j] -= 1<<t;
                    cell[i/3][j/3] -= 1<<t;

                }
                else cnt++;
            }

        dfs(cnt, board);

    }

    bool dfs(int cnt, vector<vector<char>>& board)
    {
        if(cnt==0) return true;

        int mv=10;
        int x,y;
        for(int i=0;i<9;++i)
            for(int j=0;j<9;++j)
            {
                if(board[i][j]=='.')
                {
                    int t=ones[get(i, j)];
                    if(t < mv)
                    {
                        mv=t;
                        x=i;y=j;
                    }
                }
            }

        for(int i=get(x, y); i; i-=lowbit(i))
        {
            int t=map[lowbit(i)];

            row[x] -= 1<<t;
            col[y] -= 1<<t;
            cell[x/3][y/3] -=1<<t;
            board[x][y]= t+'1';

            if(dfs(cnt-1, board)) return true;

            row[x] += 1<<t;
            col[y] += 1<<t;
            cell[x/3][y/3] += 1<<t;
            board[x][y]='.';
        }

        return false;
    }
};



