460. LFU缓存


请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。

get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
put(key, value) - 如果键已存在，则变更其值；如果键不存在，请插入键值对。
当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除最久未使用的键。
「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

 

进阶：
你是否可以在 O(1) 时间复杂度内执行两项操作？



######################################33 

Olgn

//0820 

struct Node
{
    int cnt;//频率
    int time;//访问时间
    int key;
    int val;
    Node(int _cnt,int _time,int _key,int _val):cnt(_cnt),time(_time),key(_key),val(_val){}

    bool operator<(const Node& rhs) const  //node类型的排序，频率小的在前，频率相等就最少访问的在前
    {
        if(rhs.cnt==cnt)
        {
            return time<rhs.time;
        }
        else
        {
            return cnt<rhs.cnt;
        }
    }

};

class LFUCache 
{
public:

    int cp;
    int time;
    unordered_map<int,Node> mp;
    set<Node> st;

    LFUCache(int capacity) 
    {
        cp=capacity;
        time=0;
        mp.clear();
        st.clear();
    }
    
    int get(int key) 
    {
        if(cp==0) return -1;
        auto it=mp.find(key);
        if(it!=mp.end())
        {
            Node tmp=it->second;
            
            st.erase(tmp);//从树中删除原来的节点
            //更新 节点
            tmp.cnt++;
            time++;
            tmp.time+=time;
            // 将新缓存重新放入哈希表和平衡二叉树中
            st.insert(tmp);
            it->second=tmp;
            
            return tmp.val;
        }
        else
        {
            return -1;
        }
    }
    
    void put(int key, int value) //插入元素
    {
        if(cp==0) return;
        auto it=mp.find(key);
        if(it!=mp.end())//已经存在进行更新
        {
            Node tmp=it->second;
            
            st.erase(tmp);

            tmp.cnt++;
            time++;
            tmp.time+=time;
            tmp.val=value;

            st.insert(tmp);
            it->second=tmp;
        }
        else //没有找到节点
        {
            if(mp.size()==cp)//已经满了，删除最近没有使用的
            {
                mp.erase(st.begin()->key);
                st.erase(st.begin());//
            }
            //下面的不需要else ，因为if结束后，都要执行的插入节点，
            Node newnode=Node(1,++time,key,value);
            st.insert(newnode);
            mp.insert(make_pair(key,newnode));
            
        }
    }
};


/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache* obj = new LFUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
