494. 目标和
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

 

示例：

输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
 

提示：

数组非空，且长度不会超过 20 。
初始的数组的和不会超过 1000 。
保证返回的最终结果能被 32 位整数存下。



----------------------------------- 0119 / 2021 / yxc


// 一看就是dp，

// dp[i][j]前i个数满足和是j的方案数，dp[n][s],
// dp[i][j]=dp[i-1][j-ai] + dp[i-1][j+ai] ai为正或者为负数，划分集合

// 但是不会写怎么计算

// 初始数组和不超过1000，所以总和范围则是-1000～1000
// 时间 i是20， j是2000，所以是4e4复杂度



class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
    
        if(S> 1000 || S < -1000) return 0;
        int n = nums.size();
        vector<vector<int>> f(n+1, vector<int>(2010));
        int t=1000;//因为下标不能为负数，所以要加上偏移
        f[0][t]=1;

        for(int i=1;i<=n;++i) // 前i个数
        {
            for(int j=-1000;j<=1000;++j) // 总和j
            {
                if(j-nums[i-1] >= -1000) // a[i-1] 取正
                    f[i][j+t] += f[i-1][j-nums[i-1]+t];

                if(j+nums[i-1]<= 1000) // a[i-1] 取负数
                    f[i][j+t] += f[i-1][j+nums[i-1]+t];
            }
        }   

        return f[n][S+t];
    }
};




