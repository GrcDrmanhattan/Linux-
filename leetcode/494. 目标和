494. 目标和
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

 

示例：

输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5
解释：

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
 

提示：

数组非空，且长度不会超过 20 。
初始的数组的和不会超过 1000 。
保证返回的最终结果能被 32 位整数存下。



----------------------------------- 0119 / 2021 / yxc


// 一看就是dp，

// dp[i][j]前i个数满足和是j的方案数，dp[n][s],
// dp[i][j]=dp[i-1][j-ai] + dp[i-1][j+ai] ai为正或者为负数，划分集合

// 但是不会写怎么计算

// 初始数组和不超过1000，所以总和范围则是-1000～1000
// 时间 i是20， j是2000，所以是4e4复杂度



class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
    
        if(S> 1000 || S < -1000) return 0;
        int n = nums.size();
        vector<vector<int>> f(n+1, vector<int>(2010));
        int t=1000;//因为下标不能为负数，所以要加上偏移
        f[0][t]=1;

        for(int i=1;i<=n;++i) // 前i个数
        {
            for(int j=-1000;j<=1000;++j) // 总和j
            {
                if(j-nums[i-1] >= -1000) // a[i-1] 取正
                    f[i][j+t] += f[i-1][j-nums[i-1]+t];

                if(j+nums[i-1]<= 1000) // a[i-1] 取负数
                    f[i][j+t] += f[i-1][j+nums[i-1]+t];
            }
        }   

        return f[n][S+t];
    }
};



---------------------------- 0405 ‘ / 2021/  yxc


class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {
        if(S > 1000 || S<-1000) return 0;
        int n=nums.size();
        int offset=1000;
        vector<vector<int>> f(n+1, vector<int>(2001));
        f[0][0 + offset]=1;

        for(int i=1;i<=n;++i)
            for(int j=-1000;j<=1000;++j){
                if(j - nums[i-1] >= -1000){// 当ai前添加正号 ,要满足和不超过边界内也可以写成两个比较大于-1000和小于等于1000
                    f[i][j+offset] += f[i-1][j-nums[i-1]+offset];
                }
                if(j + nums[i-1] <= 1000){ // 要满足前i-1个和的范围 在[-1000, 1000]之间
                    f[i][j+offset] += f[i-1][j+nums[i-1]+offset];
                }
            }

        return f[n][S+offset];
    }
};





------------------------- 0731 / 2021 

dp


class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int s) {
        int n=nums.size();
        vector<vector<int>> f(n+1, vector<int>(2001));//前i个数和为j的，j范围-1000，1000总计2000个数
        const int b=1000;
        f[0][0+b]=1 ;

        for(int i=1;i<=n;++i)
            for(int j=-1000;j<=1000;++j){
                if(j-nums[i-1] >= -1000) // 当n[i-1]是正数，前面i-1凑出的和是j-n[i];
                    f[i][j+b] += f[i-1][j-nums[i-1]+b];
                if(j+nums[i-1] <= 1000) // 当前的数n[i-1]是负数，
                    f[i][j+b] += f[i-1][j+nums[i-1]+b];
            }

        return f[n][s+b];
    }
};


