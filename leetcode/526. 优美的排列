526. 优美的排列

假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：

第 i 位的数字能被 i 整除
i 能被第 i 位上的数字整除
现在给定一个整数 N，请问可以构造多少个优美的排列？

示例1:

输入: 2
输出: 2
解释: 

第 1 个优美的排列是 [1, 2]:
  第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除

第 2 个优美的排列是 [2, 1]:
  第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
  第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
说明:

N 是一个正整数，并且不会超过15。


--------------------------------------- 0118 / 2021 / yxc

// 被2整除的数的特征：一个整数的末位是偶数（0、2、4、6、8）的数能被2整除


// 1到n，排列总计n！个
// n 比较小，可以状态压缩dp

// 时间复杂度 状态数 2^n 枚举需要On， 总计n * (2 ^n), 50万

// dp[i] 表示将i用二进制表示，其中被选择的数字的排列数有多少种

class Solution {
public:
    int countArrangement(int n) {
        vector<int> f(1<<n);

        f[0]=1;
        for(int i=0;i< 1<<n;++i) // 二进制状态为1表示这个数被用过，为0表示没有用过
        {
            int k=0;
            for(int j=0;j<n;++j)
                if(i>>j&1) k++; // 如果第j个数被用过，k++，结束后 k是需要放数的位置
                
            for(int j=0;j<n;++j) // 枚举要放哪个数
                if(!(i>>j&1)) // 第j位不是1，即第j个数没有使用过
                {
                    if((k+1) % (j+1)==0 || (j+1) % (k+1)==0)
                        f[i | (1<<j)] += f[i];// f[i | (1<<j)] 将第j位变为1
                }
        }

         return f[(1<<n) - 1];
    }
};



----------------------------------------------------------- 0119 

目的 排列n个数，使得排列满足某种条件



时间 : 状态数 * 每个状态计算的时间 , 2^n * n


f[状态]  =  该状态对应的方案数

是在所有的2^n个状态中搜寻满足要求的状态，然后计算

class Solution {
public:
    int countArrangement(int n) {
        
        vector<int> f(1<<n); // n位的二进制数，表示每个数是否被用过，状态，只关心是否被用过，不关心使用的顺序
        f[0]=1;// 所有的数都没有被用过也是一个方案数

        for(int i=0;i<1<<n;++i) // 遍历每个状态,2^n个状态数
        {
            int k=0;
            for(int j=0;j<n;++j) // 看i的每一位上是否是1，如果是1表示有一个数被用过了，k记录被用过的个数
                if(i>>j&1) k++;

            for(int j=0;j<n;++j) // 看看第k+1可以使用哪个数
                if(!(i>>j&1))
                {
                    if((j+1)%(k+1)==0 || (k+1)%(j+1)==0)
                        f[i| 1<<j] += f[i];
                }
        }

        return f[(1<<n)-1]; // 返回所有个数都用过的状态对应的方案数
    }
};

