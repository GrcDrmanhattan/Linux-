5627. 石子游戏 VII

石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，爱丽丝先开始 。

有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。

鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 减小得分的差值 。爱丽丝的目标是最大限度地 扩大得分的差值 。

给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。

 

示例 1：

输入：stones = [5,3,1,4,2]
输出：6
解释：
- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。
- 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。
- 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。
- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。
- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。
得分的差值 18 - 12 = 6 。
示例 2：

输入：stones = [7,90,5,1,100,10,10,2]
输出：122
 

提示：

n == stones.length
2 <= n <= 1000
1 <= stones[i] <= 1000

----------------------------------------------------------------------------------  1213 区间dp yxc 

// f[i][j] 表示当前在区间i到j，先手减后手的最大值
// 博弈论 每次选择自己的最坏的情况中最好的结果 ，所以两个情况取max
// 区间dp


class Solution {
public:
    int stoneGameVII(vector<int>& w) {
        int n=w.size();
        vector<int> s(n+1);
        for(int i=1;i<=n;++i) s[i] = s[i-1] + w[i-1];

        vector<vector<int>> f(n+1, vector<int>(n+1));

        for(int len = 2; len <= n ; ++len)
        {
            for(int i=1; i+len-1 <= n;++i)
            {
                int j= i+ len -1;
                // 每一步，分为两个集合，取最左边的i和最右边的j 
                // 取i 剩下的和是[i+1,j]全部和，然后加上自己的最坏的情况，也就是对方最好的情况f[i+1][j]的相反数，
                // 取j 剩下的[i,j-1]的和，加上自己的最坏的情况，也就是对方最好的情况 f[i][j-1]

                f[i][j]=max(s[j] - s[i] - f[i+1][j] , s[j-1] - s[i-1] - f[i][j-1]); 
            }
        }

        return f[1][n];
    }
};

