5733. 最近的房间

一个酒店里有 n 个房间，这些房间用二维整数数组 rooms 表示，其中 rooms[i] = [roomIdi, sizei] 表示有一个房间号为 roomIdi 的房间且它的面积为 sizei 。
每一个房间号 roomIdi 保证是 独一无二 的。

同时给你 k 个查询，用二维数组 queries 表示，其中 queries[j] = [preferredj, minSizej] 。第 j 个查询的答案是满足如下条件的房间 id ：

房间的面积 至少 为 minSizej ，且
abs(id - preferredj) 的值 最小 ，其中 abs(x) 是 x 的绝对值。
如果差的绝对值有 相等 的，选择 最小 的 id 。如果 没有满足条件的房间 ，答案为 -1 。

请你返回长度为 k 的数组 answer ，其中 answer[j] 为第 j 个查询的结果。

 

示例 1：

输入：rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]]
输出：[3,-1,3]
解释：查询的答案如下：
查询 [3,1] ：房间 3 的面积为 2 ，大于等于 1 ，且号码是最接近 3 的，为 abs(3 - 3) = 0 ，所以答案为 3 。
查询 [3,3] ：没有房间的面积至少为 3 ，所以答案为 -1 。
查询 [5,2] ：房间 3 的面积为 2 ，大于等于 2 ，且号码是最接近 5 的，为 abs(3 - 5) = 2 ，所以答案为 3 。
示例 2：

输入：rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]]
输出：[2,1,3]
解释：查询的答案如下：
查询 [2,3] ：房间 2 的面积为 3 ，大于等于 3 ，且号码是最接近的，为 abs(2 - 2) = 0 ，所以答案为 2 。
查询 [2,4] ：房间 1 和 3 的面积都至少为 4 ，答案为 1 因为它房间编号更小。
查询 [2,5] ：房间 3 是唯一面积大于等于 5 的，所以答案为 3 。
 

提示：

n == rooms.length
1 <= n <= 105
k == queries.length
1 <= k <= 104
1 <= roomIdi, preferredj <= 107
1 <= sizei, minSizej <= 107


------------------------- 0502 / 2021/  yxc

// 要学会如何在变换顺序后，输出答案对应的原数组的下标，因为要输出原来的下标


class Solution {
public:
    struct Query{
        int id;
        int p;
        int m;

        bool operator<(const Query& t){
            return m < t.m;
        }
    };

    vector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) {
        int n=queries.size();
        vector<int> res(n);
        vector<Query> q;

        for(int i=0;i<n;++i){
            q.push_back({i, queries[i][0], queries[i][1]});
        }

        sort(q.begin(), q.end()); // 将查询排序，按照minsize从小到大排序
        sort(rooms.begin(), rooms.end(),[](vector<int>& a ,vector<int>& b){
            return a[1] < b[1];
        }); // 
        const int inf=1e9;
        set<int> s{-inf, inf};

        for(int i=n-1, j=rooms.size()-1;i>=0;--i){ // 按照从大到小枚举每个查询，这样满足条件的房间数目是逐渐递增的，
            while(j>=0 && rooms[j][1] >= q[i].m) s.insert(rooms[j--][0]); 
            //将满足条件的房间id加入set，然后二分看左右最近的边界那个距离更小

            int p=q[i].p;
            int id=q[i].id;

            auto k=s.lower_bound(p); // k是大于等于p的最小值
            auto u=k;
            --u;
            // u  p  k
            if(p - *u <= *k - p) res[id] = *u;
            else res[id]=*k;

            if(abs(res[id]) == inf) res[id]=-1;
            
        }
        return res;
    }
};



-------------------------- 0502  思路顺畅

// 先找到满足大于等于minsize的所有id，然后在集合里二分找答案

class Solution {
public:
    struct node{
        int idx;
        int p;
        int m;
        bool operator<(const node &t){
            return m < t.m;
        }
    };

    vector<int> closestRoom(vector<vector<int>>& rooms, vector<vector<int>>& queries) {
        int n=queries.size();
        vector<int> res(n);
        const int inf=1e9;
        vector<node> q;
        for(int i=0;i<n;++i){
            q.push_back({i, queries[i][0], queries[i][1]});
        }

        sort(rooms.begin(), rooms.end(), [](vector<int>& a, vector<int>& b){
            return a[1] < b[1];
        });

        sort(q.begin(), q.end());
        
        set<int> s{-inf, inf};
        for(int i=n-1, j=rooms.size()-1; i>=0;--i){
            while(j>=0 && rooms[j][1] >= q[i].m){
                s.insert(rooms[j][0]);
                j--;
            }

            int p=q[i].p;
            int idx=q[i].idx;

            auto k=s.lower_bound(p);
            auto u=k;
            --u;

            if(p - *u <= *k -p) res[idx] = *u;
            else res[idx]= *k;

            if(abs(res[idx]) == inf) res[idx]=-1;
        }

        return res;
    }
};



