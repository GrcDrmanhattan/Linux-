5847. 找到所有的农场组

给你一个下标从 0 开始，大小为 m x n 的二进制矩阵 land ，其中 0 表示一单位的森林土地，1 表示一单位的农场土地。

为了让农场保持有序，农场土地之间以矩形的 农场组 的形式存在。每一个农场组都 仅 包含农场土地。且题目保证不会有两个农场组相邻，也就是说一个农场组中的任何一块土地都 不会 
与另一个农场组的任何一块土地在四个方向上相邻。

land 可以用坐标系统表示，其中 land 左上角坐标为 (0, 0) ，右下角坐标为 (m-1, n-1) 。请你找到所有 农场组 最左上角和最右下角的坐标。一个左上角坐标为 (r1, c1) 
且右下角坐标为 (r2, c2) 的 农场组 用长度为 4 的数组 [r1, c1, r2, c2] 表示。

请你返回一个二维数组，它包含若干个长度为 4 的子数组，每个子数组表示 land 中的一个 农场组 。如果没有任何农场组，请你返回一个空数组。可以以 任意顺序 返回所有农场组。

示例 1：



输入：land = [[1,0,0],[0,1,1],[0,1,1]]
输出：[[0,0,0,0],[1,1,2,2]]
解释：
第一个农场组的左上角为 land[0][0] ，右下角为 land[0][0] 。
第二个农场组的左上角为 land[1][1] ，右下角为 land[2][2] 。
示例 2：



输入：land = [[1,1],[1,1]]
输出：[[0,0,1,1]]
解释：
第一个农场组左上角为 land[0][0] ，右下角为 land[1][1] 。
示例 3：



输入：land = [[0]]
输出：[]
解释：
没有任何农场组。
 

提示：

m == land.length
n == land[i].length
1 <= m, n <= 300
land 只包含 0 和 1 。
农场组都是 矩形 的形状。

--------------------------- 0905 / 2021   60双周赛 2


关键信息：题目保证不会有两个农场组相邻，寻找一个农场组的入口就是：当前元素为1，且上面一个元素是0或在上边界，左边一个元素也是0或在左边界



#include<bits/stdc++.h>
using namespace std;
class Solution {
public:
    vector<vector<int>> findFarmland(vector<vector<int>>& land) {
        vector<vector<int>> ans;
        for(int i=0;i<land.size();i++){
            for(int j=0;j<land[i].size();j++){
                if((i==0||land[i-1][j]==0) && (j==0||land[i][j-1]==0) && land[i][j]==1)//左上交
                {
                    int right=j;
                    while(right<land[i].size()&&land[i][right]==1)right++;
                    int down=i;
                    while(down<land.size()&&land[down][j]==1)down++;

                    ans.push_back(vector<int>({i,j,down-1,right-1}));
                }
            }
        }
        return ans;
    }
};



------------------- 0905 / yxc 

class Solution {
public:
    vector<vector<int>> findFarmland(vector<vector<int>>& g) {
        vector<vector<int>> res;
        const int n=g.size();
        const int m=g[0].size();

        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(g[i][j]){
                    int x=i;
                    int y=j;
                    int c=x;
                    int d=y;
                    for(int a=i;a<n && g[a][j];++a){
                        for(int b=j;b<m && g[a][b];++b){
                            g[a][b]=0;
                            c=max(c, a);
                            d=max(d ,b);
                            
                        }
                    }
                    res.push_back({x, y, c, d});
                }
            }
        }

        return res;
    }
};




------------------------------   yxc

class Solution {
public:
    vector<vector<int>> findFarmland(vector<vector<int>>& g) {
        const int n=g.size();
        const int m=g[0].size();
        vector<vector<int>> res;

        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(g[i][j]==1){
                    int x=i;
                    int y=j;
                    for(int a=i;a<n && g[a][j];++a){
                        for(int b=j;b<m && g[a][b];++b){
                            g[a][b]=0;
                            x=max(x, a);
                            y=max(y, b);
                        }
                    }

                    res.push_back({i, j, x, y});
                }
            }
        }

        return res;
    }
};




