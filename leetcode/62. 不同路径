一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

=================================== 动态规划画表格求值而已



class Solution  //自己画表就可以了，是否补边界，写一下接可以
{
public:
    int uniquePaths(int m, int n) //改变参数的顺序变为m行n列,
    //经试验，m行n列可以，m列n行可以，就是求m-1，n-1这个坐标的值而已！！！
    {
        //本题 n行 m、列，其实无所谓
        vector<vector<int> > dp(n+1,vector<int>(m+1,0));
        for(int i=0;i<n+1;++i) dp[i][0]=1;//第 0列 初始化为1
        for(int i=0;i<m+1;++i) dp[0][i]=1;//第 0行 初始化1

        for(int i=1;i<n;++i)//因为i=0已经初始化了，=号会溢出int？？
        {
            for(int j=1;j<m;++j)//因为j=0，已经初始化了
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }        

        return dp[n-1][m-1];
    }

};

===============================不补充边界
class Solution
{
public:
    int uniquePaths(int m, int n)
    {
        vector<vector<int>> dp(n,vector<int>(m,1));
        // for(int i=0;i<n;++i) dp[i][0]=1;
        // for(int i=0;i<m;++i) dp[0][i]=1;
        for(int i=1;i<n;++i)
        {
            for(int j=1;j<m;++j)
            {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }

        return dp[n-1][m-1];
    }
};

