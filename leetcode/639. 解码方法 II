639. 解码方法 II

一条包含字母 A-Z 的消息通过以下的方式进行了编码：

'A' -> 1
'B' -> 2
...
'Z' -> 26
除了上述的条件以外，现在加密字符串可以包含字符 '*'了，字符'*'可以被当做1到9当中的任意一个数字。

给定一条包含数字和字符'*'的加密信息，请确定解码方法的总数。

同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出）

示例 1 :

输入: "*"
输出: 9
解释: 加密的信息可以被解密为: "A", "B", "C", "D", "E", "F", "G", "H", "I".
示例 2 :

输入: "1*"
输出: 9 + 9 = 18（翻译者标注：这里1*可以分解为1,* 或者当做1*来处理，所以结果是9+9=18）
说明 :

输入的字符串长度范围是 [1, 105]。
输入的字符串只会包含字符 '*' 和 数字'0' - '9'。



-------------------------- 0421/  2021/  yxc 



// j=1, j+'0' 是将数字1转换为字符'1'

时间O（26n）


class Solution {
public:
    int numDecodings(string s) {
        int n=s.size();
        const int md=1e9+7;
        vector<long long > f(n+1);
        f[0]=1;
        
        for(int i=1;i<=n;++i){
            char a=s[i-1];
            for(int j=1;j<=26;++j){
                if(j<=9) // j小于等于9时，匹配单个字符
                {
                    if(a=='*' || a==j+'0') f[i] += f[i-1];
                }
                else if(i>=2){ // 结尾两位字符要匹配ba
                    char b=s[i-2];
                    int y=j/10;
                    int x=j%10;
                    
                    if((b=='*' && y|| b==y+'0' ) && (a=='*' && x || a==x+'0'))
                        f[i] += f[i-2];
                }

                f[i] %= md;
            }
        }

        return f[n];
    }
};



