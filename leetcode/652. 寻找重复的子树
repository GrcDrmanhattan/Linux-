652. 寻找重复的子树

给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

两棵树重复是指它们具有相同的结构以及相同的结点值。

示例 1：

        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
下面是两个重复的子树：

      2
     /
    4
和

    4
因此，你需要以列表的形式返回上述重复子树的根结点。


-------------------------- 0926   /2021 yxc

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*>  res;
    unordered_map<string, int> ids; // 将三元组映射到id
    unordered_map<int,int> mp; // 将id映射到个数cnt
    int cnt=0;

    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        return res;

    }

    int dfs(TreeNode* p){
        if(!p) return 0;
        int ll=dfs(p->left);
        int rr=dfs(p->right);

        string key=to_string(p->val) + ' '+to_string(ll) +' '+to_string(rr);//三元组
        if(ids.count(key) ==0) ids[key]=++cnt;

        int id=ids[key];

        if(++mp[id]==2) res.push_back(p); // 出现第二次，加入答案
        return id;
    }
};



------------- 

class Solution {
public:
    unordered_map<int, int> mp;
    unordered_map<string ,int> ids;
    int cnt;
    vector<TreeNode*> res;

    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        return res;
    }

    int dfs(TreeNode* p){
        if(!p) return 0;

        int ll=dfs(p->left);
        int rr=dfs(p->right);

        string key=to_string(p->val) + ' '+to_string(ll)+' '+to_string(rr);
        if(ids.count(key)==0){ // 三元组没有出现过,说明第一次出现结构
            cnt++;
            ids[key]=cnt;
        }

        int ans=ids[key]; // 
        
        mp[ans]++;
        if(mp[ans]==2) res.push_back(p);

        return ans;
    }
};


------------------

class Solution {
public:
    vector<TreeNode*> res;
    unordered_map<string, int> ids;
    unordered_map<int,int> mp;
    int cnt=0;

    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        dfs(root);
        return res;
    }

    int dfs(TreeNode* p){
        if(!p) return 0;
        int ll=dfs(p->left);
        int rr=dfs(p->right);

        string key=to_string(p->val) + to_string(ll)+to_string(rr);

        if(ids.count(key)==0) { //  结构第一次出现，赋值一个新的id
            cnt++;
            ids[key]=cnt;
        }

        int ans=ids[key]; //结构不是第一次出现，取id，然后出现次数++

        mp[ans]++;
        if(mp[ans]==2) res.push_back(p);

        return ans;
    }
};

