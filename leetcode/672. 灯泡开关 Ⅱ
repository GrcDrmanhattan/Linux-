672. 灯泡开关 Ⅱ

现有一个房间，墙上挂有 n 只已经打开的灯泡和 4 个按钮。在进行了 m 次未知操作后，你需要返回这 n 只灯泡可能有多少种不同的状态。

假设这 n 只灯泡被编号为 [1, 2, 3 ..., n]，这 4 个按钮的功能如下：

将所有灯泡的状态反转（即开变为关，关变为开）
将编号为偶数的灯泡的状态反转
将编号为奇数的灯泡的状态反转
将编号为 3k+1 的灯泡的状态反转（k = 0, 1, 2, ...)
示例 1:

输入: n = 1, m = 1.
输出: 2
说明: 状态为: [开], [关]
示例 2:

输入: n = 2, m = 1.
输出: 3
说明: 状态为: [开, 关], [关, 开], [关, 关]
示例 3:

输入: n = 3, m = 1.
输出: 4
说明: 状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].
注意： n 和 m 都属于 [0, 1000].
------------------ 0929  / 2021   yxc 


class Solution {
public:
    int state[8][6]={
        {1, 1, 1, 1, 1, 1}, // 0初始
        {0, 0, 0, 0, 0, 0}, // 1所有反转
        {1, 0, 1, 0, 1, 0,}, // 2 偶数反转
        {0, 1, 0, 1, 0, 1}, // 3 奇数反转
        {0, 1, 1, 0, 1, 1}, // 4 1，4反转
        {1, 0, 0, 1, 0, 0}, // 14状态
        {0, 0, 1, 1, 1, 0}, // 24
        {1, 1, 0, 0, 0, 1}, // 34
    };

    int flipLights(int n, int m) {
        n=min(n, 6);
        if(m==0) return work(n, {0});
        else if(m==1) return work(n, {1, 2, 3, 4});//操作1次可以得到的状态
        else if(m==2) return work(n, {0, 1, 2, 3, 5, 6, 7});// 操作两次可以得到的状态
        else return work(n, {0, 1, 2, 3, 4, 5, 6, 7});
    }

    int work(int n, vector<int> op){
        set<int> st;
        for(auto x:op){
            int num=0;
            for(int i=0;i<n;++i){
                num = num *2 +state[x][i];//将状态转换为二进制数
            }
            st.insert(num);
        }

        return st.size();
    }
};


