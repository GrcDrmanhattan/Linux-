691. 贴纸拼词

我们给出了 N 种不同类型的贴纸。每个贴纸上都有一个小写的英文单词。

你希望从自己的贴纸集合中裁剪单个字母并重新排列它们，从而拼写出给定的目标字符串 target。

如果你愿意的话，你可以不止一次地使用每一张贴纸，而且每一张贴纸的数量都是无限的。

拼出目标 target 所需的最小贴纸数量是多少？如果任务不可能，则返回 -1。

 

示例 1：

输入：

["with", "example", "science"], "thehat"
输出：

3
解释：

我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。
把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。
此外，这是形成目标字符串所需的最小贴纸数量。
示例 2：

输入：

["notice", "possible"], "basicbasic"
输出：

-1
解释：

我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。
 

提示：

stickers 长度范围是 [1, 50]。
stickers 由小写英文单词组成（不带撇号）。
target 的长度在 [1, 15] 范围内，由小写字母组成。
在所有的测试案例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选取的，目标是两个随机单词的串联。
时间限制可能比平时更具挑战性。预计 50 个贴纸的测试案例平均可在35ms内解决。

---------------- 0913  /2021  / yxc

class Solution {
public:
    const int inf=20;
    vector<string> strs;
    string tar;
    static const int N=1<<15;
    int f[N];
    int g[N][26];
    int n;

    int minStickers(vector<string>& stickers, string target) {
        tar=target;
        strs=stickers;
        n=tar.size();
        memset(f, -1, sizeof(f));
        memset(g, -1, sizeof(g));

        int res=dfs(0);
        if(res == inf) return -1;
        return res;
    }

    int dfs(int state){
        auto &v=f[state];
        if(v!=-1) return v;
        if(state == (1<<n)-1) return v=0;
        v=inf;
        for(auto w:strs){
            auto cur=state;
            for(auto x:w){
                cur = fill(cur, x);
                if(cur != state) v=min(v,dfs(cur) + 1);
            }
        }
        return v;
    }

    int fill(int state, char c){ // 将当前状态的某位替换成字母c之后的状态
        if(g[state][c-'a'] != -1) return g[state][c-'a'];
        auto& v=g[state][c-'a'];
        v=state;

        for(int i=0;i<n;++i){
            if(!(state>>i&1) && tar[i]==c) {
                v += 1<<i;
                break;
            }
        }
        return v;
    }
};



------------- 0915  /2021 

class Solution {
public:
    static const int N=1<<15;
    const int inf=20;
    int n;
    vector<string> stickers;
    string tar;
    int f[N]; // 满足当前状态的贴纸数目
    int g[N][26]; // 当前状态n替换一个字母为x后的状态是多少

    int minStickers(vector<string>& _stickers, string target) {
        tar=target;
        stickers=_stickers;
        n=tar.size();
        memset(f, -1, sizeof(f));
        memset(g, -1, sizeof(g));
        
        int res=dfs(0);
        if(res == inf) return -1;
        return res;
    }

    int dfs(int state){
        auto &v=f[state];
        if(v!= -1) return v;
        if(state == (1<<n)-1) return v=0;
        v=inf;

        for(auto w:stickers){
            auto cur=state;
            for(auto x:w){
                cur=fill(cur, x);
                if(cur != state) v=min(v, dfs(cur)+1);
            }
        }

        return v;
    }

    int fill(int state, char x){
        auto &v=g[state][x-'a'];
        if(v != -1) return v;
        v=state;

        for(int i=0;i<n;++i){
            if(!(state>>i&1) && tar[i] == x){
                v |= 1<<i;
                break;
            }
        }

        return v;
    }
};

