743. 网络延迟时间

有 n 个网络节点，标记为 1 到 n。

给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

 

示例 1：



输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
示例 2：

输入：times = [[1,2,1]], n = 2, k = 1
输出：1
示例 3：

输入：times = [[1,2,1]], n = 2, k = 2
输出：-1
 

提示：

1 <= k <= n <= 100
1 <= times.length <= 6000
times[i].length == 3
1 <= ui, vi <= n
ui != vi
0 <= wi <= 100
所有 (ui, vi) 对都 互不相同（即，不含重复边）
------------------------ 1009 / 2021  yxc  
亚马逊面试题·

const int N=100, M=60010, inf=0x3f3f3f3f;
bool st[N];
int dis[M];

int w[M];
int h[N];
int id;
int ne[M];
int e[M];

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        memset(h, -1, sizeof(h));
        id=0;
        for(auto x:times){
            int a=x[0];
            int b=x[1];
            int c=x[2];
            add(a, b, c);
        }

        int res=1;
        spfa(k);
        for(int i=1;i<=n;++i) res=max(res, dis[i]);
        if(res == inf) return -1;
        return res;
    }

    void add(int a, int b, int c){
        e[id]=b;
        w[id]=c;
        ne[id]=h[a];
        h[a]=id;
        id++;
    }

    void spfa(int start){
        queue<int> q;
        memset(dis, 0x3f, sizeof(dis));
        dis[start]=0;
        q.push(start);

        st[start]=true;

        while(q.size()){
            auto t=q.front();
            q.pop();
            st[t]=false;

            for(int i=h[t];i!=-1;i=ne[i]){
                int j=e[i];
                if(dis[j] > dis[t] + w[i]){
                    dis[j] = dis[t] + w[i];
                    if(!st[j]){
                        st[j]=true;
                        q.push(j);
                    }
                }
            }
        }
    }
};

------------- 

const int N=100, M=60010, inf = 0x3f3f3f3f;

int dis[N];
bool st[N];

int id;
int h[N];
int e[M];
int ne[M];
int w[M];

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        memset(h, -1, sizeof(h));
        id=0;

        for(auto x:times){
            int a=x[0];
            int b=x[1];
            int c=x[2];
            add(a, b, c);
        }

        int res=1;
        spfa(k);
        for(int i=1;i<=n;++i) res=max(res, dis[i]);
        if(res == inf) return -1;
        return res;
    }

    void add(int a, int b, int c){
        e[id]=b;
        w[id]=c;
        ne[id]=h[a];
        h[a]=id;
        id++;
    }

    void spfa(int start){
        queue<int> q;
        memset(dis, 0x3f, sizeof(dis));
        dis[start]=0;
        q.push(start);
        st[start]= true;

        while(q.size()){
            auto t=q.front();
            q.pop();
            st[t]=false;

            for(int i=h[t];i!=-1; i=ne[i]){
                int j=e[i];
                if(dis[j] > dis[t] + w[i]){
                    dis[j] = dis[t] + w[i];
                    if(!st[j]){
                        q.push(j);
                        st[j]=true;
                    }
                }
            }
        }
    }
};



-------------- 1014  / 2021   


// spfa求k到所有点的最短距离，然后遍历每个点取max
const int N=110;
const int M=60010;
const int inf=0x3f3f3f3f;

int id;
int h[N];
int w[M];
int e[M];
int ne[M];

int dis[N];
bool st[N];

class Solution {
public:

    void add(int a, int b ,int c){
        e[id]=b;
        w[id]=c;
        ne[id]=h[a];
        h[a]=id;
        id++;
    }

    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        id=0;
        memset(h, -1, sizeof(h));
        
        for(auto &x:times){
            int a=x[0];
            int b=x[1];
            int c=x[2];
            add(a, b,c);
        }
        spfa(k);
        int res=0;
        for(int i=1;i<=n;++i) res=max(res, dis[i]);
        if(res == inf) return -1;
        return res;
    }

    void spfa(int start){
        memset(dis, 0x3f, sizeof(dis));
        dis[start]=0;
        st[start]=true;
        queue<int> q;
        q.push(start);

        while(q.size()){
            auto t=q.front();
            q.pop();
            st[t]=false;

            for(int i=h[t];i!=-1;i=ne[i]){
                int j=e[i];
                if(dis[j] > dis[t]+w[i]){
                    dis[j]=dis[t]+w[i];
                    if(!st[j]) q.push(j);
                }
            }
        }
    }
};



