75. 颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

 

进阶：

你可以不使用代码库中的排序函数来解决这道题吗？
你能想出一个仅使用常数空间的一趟扫描算法吗？
 

示例 1：

输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
示例 2：

输入：nums = [2,0,1]
输出：[0,1,2]
示例 3：

输入：nums = [0]
输出：[0]
示例 4：

输入：nums = [1]
输出：[1]
 

提示：

n == nums.length
1 <= n <= 300
nums[i] 为 0、1 或 2
------------------------------- 0107 /2021 /yxc



// 0 到  j-1 全是0， j到 i-1 全是1， k到 n-1 全是2
// 每次枚举i， 维护jk指针


class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n=nums.size();
        for(int i=0, j=0, k=n-1;i<=k;)
        {
            if(nums[i]==0) swap(nums[i++], nums[j++]);
            else if (nums[i]==2) swap(nums[i], nums[k--]);
            else i++;
        }

    }
};



---------------------------------- 0310  /2021/ 

class Solution {
public:
    void sortColors(vector<int>& nums) {
        int j=0;
        for(int i=0, k=nums.size()-1; i<=k;)
        {
            if(nums[i]==2) swap(nums[i], nums[k--]);
            else if(nums[i]==0) swap(nums[i++], nums[j++]);
            else i++;
        }
    }
};



-------------------------- 0705 / 2021/ 

class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n=nums.size();
        for(int i=0, j=0, k=n-1;i<=k;){
            if(nums[i]==0) swap(nums[i++], nums[j++]); // 先交换，后修改范围
            else if(nums[i]==2) swap(nums[i], nums[k--]);
            else i++;
        }
    }
};

------------ 1026  

class Solution {
public:
    void sortColors(vector<int>& nums) {
        const int n=nums.size();
        for(int i=0, j=0, k=n-1;i<=k;){ // ik两个双指针，还需要一个指针j遍历
            if(nums[i]==2) swap(nums[i], nums[k--]);
            else if(nums[i]==0) swap(nums[i++], nums[j++]);
            else i++;
        }
    }
};
class Solution {
public:
    void sortColors(vector<int>& nums) {
        const int n=nums.size();
        for(int i=0, j=0, k=n-1;i<=k;){ // [0,j-1]是0，[j,i-1]是1，[k,n-1]是2
            if(nums[i] == 2) swap(nums[i], nums[k--]); // 交换后i不一定是1，所以不能移动位置
            else if(nums[i] == 0) swap(nums[i++] , nums[j++]); // 因为要使得到i-1之间是1，不包含i所以i可以++
            else i++;
        }
    }
};
