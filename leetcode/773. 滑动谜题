773. 滑动谜题

在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.

一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.

最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。

给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

示例：

输入：board = [[1,2,3],[4,0,5]]
输出：1
解释：交换 0 和 5 ，1 步完成
输入：board = [[1,2,3],[5,4,0]]
输出：-1
解释：没有办法完成谜板
输入：board = [[4,1,2],[5,0,3]]
输出：5
解释：
最少完成谜板的最少移动次数是 5 ，
一种移动路径:
尚未移动: [[4,1,2],[5,0,3]]
移动 1 次: [[4,1,2],[0,5,3]]
移动 2 次: [[0,1,2],[4,5,3]]
移动 3 次: [[1,0,2],[4,5,3]]
移动 4 次: [[1,2,0],[4,5,3]]
移动 5 次: [[1,2,3],[4,5,0]]
输入：board = [[3,2,4],[1,5,0]]
输出：14
提示：

board 是一个如上所述的 2 x 3 的数组.
board[i][j] 是一个 [0, 1, 2, 3, 4, 5] 的排列.

------------------ 1013  /  2021   yxc 


using vii=vector<vector<int>> ;
int dx[4]={0, 1, 0, -1};
int dy[4]={1, 0, -1, 0};

class Solution {
public:
    int slidingPuzzle(vector<vector<int>>& board) {
        vii end ={{1, 2, 3}, {4, 5, 0}};
        map<vii, int> dis;
        if(board == end) return 0;
        dis[board]=0;
        queue<vii> q;
        q.push(board);

        while(q.size()){
            auto t=q.front();
            q.pop();

            int x,y;
            for(int i=0;i<2;++i)
                for(int j=0;j<3;++j){
                    if(t[i][j]==0)
                        x=i, y=j;
                }

            for(int i=0;i<4;++i){
                int a=x+dx[i];
                int b=y+dy[i];
                if(a>=0 && a< 2 && b>=0 && b<3){
                    auto tmp=t;
                    swap(tmp[a][b], tmp[x][y]);
                    if(dis.count(tmp)==0){
                        dis[tmp]= dis[t]+1;
                        if(tmp == end) return dis[tmp];
                        q.push(tmp);
                    }
                }
            }
        }

        return -1;
    }
};



