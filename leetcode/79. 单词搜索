79. 单词搜索

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

示例:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
 

提示：

board 和 word 中只包含大写和小写英文字母。
1 <= board.length <= 200
1 <= board[i].length <= 200
1 <= word.length <= 10^3

------------------------- 0310 / 2021/  


时间n^2 * (3^k). k是单词长度



class Solution {
public:
    int dx[4]={0 , 1, 0, -1};
    int dy[4]={1, 0, -1, 0};
    int n,m;
    vector<vector<char>> g;

    bool exist(vector<vector<char>>& board, string word) {
        n=board.size();
        m=board[0].size();
        g=board;

        for(int i=0;i<n;++i)
            for(int j=0;j<m;++j)
                if(dfs(i, j, 0, word)) return true;

        return false;

    }

    bool dfs(int x ,int y ,int u, string& word)
    {
        if(g[x][y] != word[u]) return false;

        if(u==word.size()-1) return true;

        char c =  word[u];
        g[x][y]='*'; // 标记防止重复使用一个位置

        for(int i=0;i<4;++i)
        {
            int a=x+dx[i];
            int b=y+dy[i];
            if(a>=0 && a<n && b>=0 && b<m)
                if(dfs(a, b, u+1, word)) return true;
        }

        g[x][y]=c;
        return false;
    }
};



-------------------- 0705 / 2021


class Solution {
public:
    int m;
    int n;
    int dx[4]={0, 1 ,0 ,-1};
    int dy[4]={1, 0, -1, 0};
    bool st[210][210];
    vector<vector<char>> g;

    bool exist(vector<vector<char>>& board, string word) {
        m=board.size();
        n=board[0].size();
        g=board;

        for(int i=0;i<m;++i)
            for(int j=0;j<n;++j){
                if(!st[i][j] && dfs(i, j, word, 0))
                    return true;
            }
        
        return false;
    }

    bool dfs(int x ,int y , string& word, int u){
        if(g[x][y] != word[u]) return false;
        if(u==word.size()-1) return true;

        st[x][y]=true;

        for(int i=0;i<4;++i){
            int a=x+dx[i];
            int b=y+dy[i];
            if(a>=0 && a<m && b>=0 && b<n && !st[a][b]){
                if(dfs(a, b, word, u+1)) return true;
            }
        }

        st[x][y]=false;
        return false;
    }
    
};



