82. 删除排序链表中的重复元素 II

存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。

返回同样按升序排列的结果链表。

 

示例 1：


输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
示例 2：


输入：head = [1,1,1,2,3]
输出：[2,3]
 

提示：

链表中节点数目在范围 [0, 300] 内
-100 <= Node.val <= 100
题目数据保证链表已经按升序排列

---------------------- 1028 / 2021   sf


/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return head;
        unordered_map<int, int> mp;
        for(auto p=head;p;p=p->next) mp[p->val]++;
        
        auto d=new ListNode(-1);
        auto c=d;

        for(auto p=head;p;p=p->next){
            if(mp[p->val] == 1) 
                c=c->next=new ListNode(p->val);
        }

        return d->next;
    }
};



------------------- yxc

class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        auto d=new ListNode(-1);
        d->next=head;
        auto c=d;

        while(c->next){// 只要c还有下一个点
            auto p=c->next;
            while(p && p->val == c->next->val) p=p->next; // p走完连续相等的一段
            if(c->next->next==p) c=c->next; // 连续一段只有一个结点
            else c->next=p;
        }

        return d->next;
    }
};


