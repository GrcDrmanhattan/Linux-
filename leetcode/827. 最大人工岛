827. 最大人工岛

给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。

返回执行此操作后，grid 中最大的岛屿面积是多少？

岛屿 由一组上、下、左、右四个方向相连的 1 形成。

 

示例 1:

输入: grid = [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
示例 2:

输入: grid = [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
示例 3:

输入: grid = [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。
 

提示：

n == grid.length
n == grid[i].length
1 <= n <= 500
grid[i][j] 为 0 或 1
-------------- 1017  / 2021  yxc



class Solution {
public:
    int n;
    vector<int> p, sz;
    int dx[4]={0, 1, 0, -1};
    int dy[4]={1, 0, -1, 0};
    
    int find(int x){
        if(p[x] != x) p[x]=find(p[x]);
        return p[x];
    }
    int get(int x, int y){
        return x * n +y;
    }

    int largestIsland(vector<vector<int>>& grid) {
        n=grid.size();
        for(int i=0;i<n*n;++i) p.push_back(i),sz.push_back(1);

        int res=1;
        //当没有0的时候，全部是1,res等于合并后的最大值
        for(int i=0;i<n;++i){
            for(int j=0;j<n;++j){
                if(grid[i][j]){
                    int a=get(i, j);
                    for(int k=0;k<4;++k){
                        int x=i+dx[k];
                        int y=j+dy[k];
                        if(x>=0 && x<n && y>=0 && y<n && grid[x][y]){
                            int b=get(x, y);
                            if(find(a) != find(b)){
                                sz[find(b)] += sz[find(a)];
                                p[find(a)] = find(b);
                            }
                        }
                    }
                    // res=max(res, sz[find(a)]); // 也可以
                }
                
            }
        }

        for(int i=0;i<n *n ;++i) res=max(res, sz[i]); // 也可以
        

        // 有0可以改变的
        for(int i=0;i<n;++i){
            for(int j=0;j<n;++j){
                if(grid[i][j] == 0){
                    unordered_map<int, int> mp;
                    for(int k=0;k<4;++k){
                        int a=i+dx[k];
                        int b=j+dy[k];
                        if(a>=0 && a<n && b>=0 && b<n && grid[a][b]){
                            int xx=get(a, b);
                            mp[find(xx)]=sz[find(xx)];
                        }
                    }

                    int s=1;
                    for(auto [x, v]:mp) s+=v;
                    res=max(res, s);
                }
            }
        }

        return res;
    }
};



------------
