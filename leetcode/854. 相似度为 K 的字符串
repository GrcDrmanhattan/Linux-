854. 相似度为 K 的字符串

如果可以通过将 A 中的两个小写字母精确地交换位置 K 次得到与 B 相等的字符串，我们称字符串 A 和 B 的相似度为 K（K 为非负整数）。

给定两个字母异位词 A 和 B ，返回 A 和 B 的相似度 K 的最小值。

 

示例 1：

输入：A = "ab", B = "ba"
输出：1
示例 2：

输入：A = "abc", B = "bca"
输出：2
示例 3：

输入：A = "abac", B = "baca"
输出：2
示例 4：

输入：A = "aabc", B = "abca"
输出：2
 

提示：

1 <= A.length == B.length <= 20
A 和 B 只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母。
--------------------- 1018 /  2021   yxc


// 两个字符串，相同位置连一个有向边，环状图

class Solution {
public:
    int kSimilarity(string s1, string s2) {
        if(s1 == s2) return 0;
        int dep=1;
        while(!dfs(s1 ,s2 , dep)) dep++;
        return dep;
    }

    int h(string& s1, string &s2){ // 启发函数
        int res=0;
        for(int i=0;i<s1.size();++i){
            if(s1[i] != s2[i]) res++;
        }
        return (res+1)/2; // 下取整代替上取整，应该是res/2向上取整
    }
    
    bool dfs(string&s1, string& s2, int dep){
        if(dep==0) return s1 == s2;

        if(h(s1, s2) > dep) return false; // 启发函数预估记的大于需要的深度，返回false

        for(int i=0;i<s1.size();++i){
            if(s1[i] != s2[i]){ // 找到第一个非自环的位置，也就是第一个不等的位置，
                for(int j=i+1;j<s1.size();++j){
                    if(s1[j] == s2[i]){ // 然后在s1找到下一个相等的位置，交换就可以
                        swap(s1[i], s1[j]);
                        if(dfs(s1, s2, dep-1)) return true;
                        swap(s1[i], s1[j]);
                    }
                }
                break;
            }
        }
        return false;
    }

};



------------------ 1019 


class Solution {
public:
    int kSimilarity(string s1, string s2) {
        if(s1 == s2) return 0;
        int dep=1;
        while(!dfs(s1, s2, dep)) dep++;
        return dep;
    }

    int h(string& s1, string& s2){
        int cnt=0;
        for(int i=0;i<s1.size();++i){
            if(s1[i] != s2[i]) cnt++;
        }

        return (cnt+1)/2;
    }

    bool dfs(string&s1 , string&s2 , int dep){
        if(dep==0) return s2==s1;
        if(h(s1, s2) > dep) return false;

        for(int i=0;i<s1.size();++i){
            if(s1[i] != s2[i]){
                for(int j=i+1;j<s1.size();++j){
                    if(s1[j] == s2[i]){
                        swap(s1[i], s1[j]);
                        if(dfs(s1, s2, dep-1)) return true;
                        swap(s1[i], s1[j]);
                    }
                }

                break;
            }
        }

        return false;
    }
};

