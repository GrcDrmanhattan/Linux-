864. 获取所有钥匙的最短路径

给定一个二维网格 grid。 "." 代表一个空房间， "#" 代表一堵墙， "@" 是起点，（"a", "b", ...）代表钥匙，（"A", "B", ...）代表锁。

我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。

假设 K 为钥匙/锁的个数，且满足 1 <= K <= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。
另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。

返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。

 

示例 1：

输入：["@.a.#","###.#","b.A.B"]
输出：8
示例 2：

输入：["@..aA","..B#.","....b"]
输出：6
 

提示：

1 <= grid.length <= 30
1 <= grid[0].length <= 30
grid[i][j] 只含有 '.', '#', '@', 'a'-'f' 以及 'A'-'F'
钥匙的数目范围是 [1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。

------------------------- 1020  / 2021  /  yxc

// 简单的bfs最短距离

class Solution {
public:
    int n, m;
    int dx[4]={0, 1, 0, -1};
    int dy[4]={1, 0, -1, 0};
    int dis[31][31][64];

    struct node{
        int x, y, s;
    };

    int shortestPathAllKeys(vector<string>& grid) {
        n=grid.size();
        m=grid[0].size();

        queue<node> q;
        int s=0; // 二进制存储钥匙的数目，每一位1标识有钥匙
        memset(dis, 0x3f, sizeof(dis));

        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(grid[i][j] == '@'){
                    dis[i][j][0]=0;
                    q.push({i, j, 0});
                }
                else if(grid[i][j] >='A' && grid[i][j] <= 'Z') s++;
            }
        }

        while(q.size()){
            auto t=q.front();
            q.pop();
            
            for(int i=0;i<4;++i){
                int a=t.x+dx[i];
                int b=t.y+dy[i];
                if(a<0 || a>=n || b<0 || b>= m || grid[a][b] == '#') continue;
                char c = grid[a][b];

                if(c >= 'a' && c <= 'z'){
                    int state=t.s | 1<< c-'a';
                    if(dis[a][b][state] > dis[t.x][t.y][t.s] + 1){
                        dis[a][b][state] = dis[t.x][t.y][t.s]+1;
                        if(state == (1<<s) -1) return dis[t.x][t.y][t.s] +1; // 返回的是老状态距离+1，也可以返回新状态距离

                        q.push({a, b, state});
                    }
                }else if(c>= 'A' && c <= 'Z'){
                    if(t.s & (1<<c-'A')){ // 有对应的钥匙
                        if(dis[a][b][t.s] > dis[t.x][t.y][t.s] + 1){
                            dis[a][b][t.s] = dis[t.x][t.y][t.s]+1;
                            q.push({a, b, t.s});
                        }
                    }
                }
                else{
                    if(dis[a][b][t.s] > dis[t.x][t.y][t.s] + 1){
                        dis[a][b][t.s] = dis[t.x][t.y][t.s]+1;
                        q.push({a, b, t.s});
                    }
                }
            }
        }

        return -1;
    }
};



-------------- 1021  / 2021  

相当于结合bfs和队列 求最短距离，结合其他因素

class Solution {
public:
    int dx[4]={0, 1, 0, -1};
    int dy[4]={1, 0, -1, 0};
    int dis[31][31][64];

    struct node{
        int x, y, s;
    };

    int shortestPathAllKeys(vector<string>& grid) {
        int n,m;
        n=grid.size();
        m=grid[0].size();
        memset(dis, 0x3f , sizeof(dis));
        queue<node> q;
        
        int keys=0;
        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(grid[i][j]=='@'){
                    dis[i][j][0]=0;
                    q.push({i, j, 0});
                }else if(grid[i][j] >= 'A' && grid[i][j] <= 'Z') keys++;
            }
        }

        while(q.size()){
            auto t=q.front();
            q.pop();
            int d=dis[t.x][t.y][t.s];

            for(int i=0;i<4;++i){
                int a=t.x+dx[i];
                int b=t.y+dy[i];
                if(a<0 || a>=n || b<0 || b>=m || grid[a][b]=='#') continue;
                char c= grid[a][b];

                if(c >= 'A' && c<='Z'){
                    if(t.s & 1 << c-'A'){
                        if(dis[a][b][t.s] > d+1){
                            dis[a][b][t.s] =d+1;
                            q.push({a, b , t.s});
                        }
                    }
                }
                else if(c >='a' && c<='z'){
                    int state = t.s |1 << c-'a';
                    if(dis[a][b][state] > d+1){
                        dis[a][b][state]=d+1;
                        if(state == (1<<keys) -1 ) return dis[a][b][state]; // 新状态的距离
                        q.push({a, b, state});
                    }
                }
                else {
                    if(dis[a][b][t.s] > d+1){
                        dis[a][b][t.s] = d+1;
                        q.push({a, b, t.s});
                    }
                }
            }
        }

        return -1;
    }
};


-------------------   1023  

class Solution {
public:
    int n,m;
    int dis[31][31][64];
    int dx[4]={0 , 1, 0, -1};
    int dy[4]={1 , 0, -1, 0};
    
    struct node{
        int x, y, s;
    };

    int shortestPathAllKeys(vector<string>& grid) {
        n=grid.size();
        m=grid[0].size();

        memset(dis, 0x3f, sizeof(dis));
        int keys=0;
        queue<node> q;

        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(grid[i][j] == '@'){
                    dis[i][j][0]=0;
                    q.push({i, j , 0});
                }
                else if(grid[i][j] >='A' && grid[i][j] <='Z') keys++;
            }
        }

        while(q.size()){
            auto t=q.front();
            q.pop();
            int d=dis[t.x][t.y][t.s];

            for(int i=0;i<4;++i){
                int a =t.x+dx[i];
                int b=t.y+dy[i];
                if(a<0 || a>= n || b<0 || b>=m || grid[a][b] =='#') continue;

                char c=grid[a][b];

                if(c>='A' && c<='Z'){
                    if(t.s & 1 << c-'A'){
                        if(dis[a][b][t.s] > d+1){
                            dis[a][b][t.s]=d+1;
                            q.push({a, b, t.s});
                        }
                    }
                }else if(c>='a' && c<='z'){
                    int state = t.s|1<<c-'a';
                    if(dis[a][b][state] > d+1){
                        dis[a][b][state]=d+1;
                        if(state == (1<<keys)-1) return dis[a][b][state];
                        q.push({a, b ,state});
                    }
                }else{
                    if(dis[a][b][t.s] > d+1){
                        dis[a][b][t.s]=d+1;
                        q.push({a, b ,t.s});
                    }
                }

            }
        }

        return -1;
    }
};


--------------- 1101  /2021  
顺畅的bfs

class Solution {
public:
    int n,m;
    int dis[32][32][64];
    int dx[4]={0, 1, 0, -1};
    int dy[4]={1, 0, -1, 0};

    struct node{
        int x, y, s;
    };

    int shortestPathAllKeys(vector<string>& grid) {
        n=grid.size();
        m=grid[0].size();
        int keys=0;
        queue<node> q;

        memset(dis, 0x3f, sizeof(dis));

        for(int i=0;i<n;++i){
            for(int j=0;j<m;++j){
                if(grid[i][j]=='@'){
                    dis[i][j][0]=0;
                    q.push({i, j, 0});
                }else if(grid[i][j]>='A' && grid[i][j]<='Z') keys++;
            }
        }

        while(q.size()){
            auto t=q.front();
            q.pop();
            int d=dis[t.x][t.y][t.s];

            for(int i=0;i<4;++i){
                int x=t.x+dx[i];
                int y=t.y+dy[i];
                
                if(x<0 || x>=n || y<0 || y>=m || grid[x][y]=='#')continue;
                
                auto c=grid[x][y];
                if(c>='A' && c<='Z'){
                    if(t.s & (1<<(c-'A'))){
                        if(dis[x][y][t.s] > d+1){
                            dis[x][y][t.s]=d+1;
                            q.push({x, y, t.s});
                        }
                    }
                }else if(c>='a' && c<='z'){
                    int state = t.s | 1<<c-'a';
                    if(dis[x][y][state] > d+1){
                        dis[x][y][state]=d+1;
                        if(state == (1<<keys)-1) return dis[x][y][state];
                        q.push({x, y, state});
                    }
                }
                else{
                    if(dis[x][y][t.s] > d+1){
                        dis[x][y][t.s] =d+1;
                        q.push({x, y, t.s});
                    }
                }
            }
        }

        return -1;
    }
};

