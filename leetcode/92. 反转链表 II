92. 反转链表 II

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL

##################################

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

//0822

class Solution 
{
    ListNode* success=NULL;
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) 
    {
        if(m==1) //相当于反转从head开始的n个节点
        {
            return reverseN(head,n);
        }

        //head->next连接 后面反转好的链表头，【从head-next开始，位置从m-1到n-1，】，因为少了head所以减1

        head->next=reverseBetween(head->next,m-1,n-1);
        return head;

    }

    //反转前n个节点
    ListNode* reverseN(ListNode* head,int n)
    {
        if(n==1)
        {
            success=head->next;
            return head;
        }

        ListNode* last=reverseN(head->next,n-1); //反转后的头
        head->next->next=head;   //把head加到反转后的链表结尾
        head->next=success;   //反转后的尾，要链接null
        return last;  //返回头
    }
};




