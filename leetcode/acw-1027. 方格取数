设有 N×N 的方格图，我们在其中的某些方格中填入正整数，而其它的方格中则放入数字0。如下图所示：

2.gif

某人从图中的左上角 A 出发，可以向下行走，也可以向右行走，直到到达右下角的 B 点。

在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。

此人从 A 点到 B 点共走了两次，试找出两条这样的路径，使得取得的数字和为最大。

输入格式
第一行为一个整数N，表示 N×N 的方格图。

接下来的每行有三个整数，第一个为行号数，第二个为列号数，第三个为在该行、该列上所放的数。

行和列编号从  1  开始。

一行“0 0 0”表示结束。

输出格式
输出一个整数，表示两条路径上取得的最大的和。

数据范围
N≤10 
输入样例：
8
2 3 13
2 6 6
3 5 7
4 4 14
5 2 21
5 6 4
6 3 15
7 2 14
0 0 0
输出样例：
67

---------------------------------------------------------------------
-----------------------------------------------------

//p->q,p是q的充分条件，
//q是p的必要条件

//k=i1+j1=i2+j2
//当两个点坐标和相等是才会重合

#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

const int N=15;

int n;
int w[N][N];
int f[N*2][N][N];//i+j,i,j

int main()
{
    scanf("%d",&n);
    int a,b,c;
    while(cin>>a>>b>>c,a||b||c) w[a][b]=c;
    
    for(int k=2;k <= n+n;++k)//初始是1+1，左上角
        for(int i1=1;i1<=n;++i1)
            for(int i2=1;i2<=n;++i2)
            {
                int j1=k-i1,j2=k-i2;
                if(j1>=1 && j1 <=n && j2>=1 && j2<=n)
                {
                    int t=w[i1][j1];
                    if(i1!=i2) t+=w[i2][j2];
                    
                    int &x=f[k][i1][i2];
                    
                    x=max(x,f[k-1][i1-1][i2-1]+t);//第一条路径最后一步向下走，第二个最后一步向下走
                    x=max(x,f[k-1][i1-1][i2]+t);//x向下，向右
                    x=max(x,f[k-1][i1][i2-1]+t);//向右，向下
                    x=max(x,f[k-1][i1][i2]+t);
                }
            }
            
    printf("%d\n",f[n+n][n][n]);
    return 0;
}


----------------- 0424 / 2021/  

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int x, y ,c;

int f[N + N][N][N];
int g[N][N];


int main()
{
    cin>>n;
    while(cin>>x>>y>>c, x||y||c) g[x][y]=c;
    
    for(int k=2;k<= n+n;++k)
        for(int i=1;i<=n;++i)
            for(int j=1;j<=n;++j)
            {
                int i1=k-i;
                int j1=k-j;
                if(i1 >= 1 && i1<=n && j1>=1 && j1<=n)
                {
                    int t=g[i][i1];
                    if(i != j) t+= g[j][j1];
                    
                    int &x=f[k][i][j];
                    
                    x=max(x, f[k-1][i-1][j-1] + t);
                    x=max(x, f[k-1][i-1][j] + t);
                    x=max(x, f[k-1][i][j-1] + t);
                    x=max(x, f[k-1][i][j] + t);
                }
            }
            
    cout<<f[n+n][n][n]<<endl;
    
    return 0;
}



