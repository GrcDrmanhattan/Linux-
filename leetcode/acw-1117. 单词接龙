1117. 单词接龙
题目描述
单词接龙是一个与我们经常玩的成语接龙相类似的游戏。

现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”，每个单词最多被使用两次。

在两个单词相连时，其重合部分合为一部分，例如 beast 和 astonish ，如果接成一条龙则变为 beastonish。

我们可以任意选择重合部分的长度，但其长度必须大于等于1，且严格小于两个串的长度，例如 at 和 atide 间不能相连。

输入格式
输入的第一行为一个单独的整数 n 表示单词数，以下 n 行每行有一个单词（只含有大写或小写字母，长度不超过20），输入的最后一行为一个单个字符，表示“龙”开头的字母。

你可以假定以此字母开头的“龙”一定存在。

输出格式
只需输出以此字母开头的最长的“龙”的长度。

数据范围
n≤20
输入样例：

5
at
touch
cheat
choose
tact
a
输出样例：
23
提示
连成的“龙”为 atoucheatactactouchoose。

###################################################

//树最多是40层
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

const int  N=21;

int n;
string word[N];
int g[N][N];//两个单词重叠的最小的长度
int used[N];//每个单词出现多少次
int ans;

void dfs(string dd,int last)//当前的最后一个单词
{
    ans=max((int)dd.size(),ans);
    
    used[last]++;
    
    for(int i=0;i<n;++i)    
        if(g[last][i] && used[i]<2)//last后面可以接i这个单词，并且次数小于2次   
        {
            dfs(dd+word[i].substr(g[last][i]),i);
        }
    
    used[last]--;
}

int main()
{
    cin>>n;
        
    for(int i=0;i<n;++i) cin>>word[i];
    char st;
    cin>>st;
    
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
        {
            string a=word[i];
            string b=word[j];
            for(int k=1;k<min(a.size(),b.size());++k)
                if(a.substr(a.size()-k,k)==b.substr(0,k))
                {
                    g[i][j]=k;
                    break;
                }
            
        }
         
    for(int i=0;i<n;++i)
        if(word[i][0]==st)
        {
            dfs(word[i],i);
        }
        
    cout<<ans<<endl;
    
    return 0;
}


#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

const int N=21;

int n;
int ans;
int g[N][N];
int used[N];
string word[N];


void dfs(string dd,int last)
{
    ans=max((int)dd.size(),ans);
    
    used[last]++;
    
    for(int i=0;i<n;++i)
    {
        if(g[last][i] && used[i]<2) dfs(dd+word[i].substr(g[last][i]),i);
    }
    
    used[last]--;
}

int main()
{
    cin>>n;
    for(int i=0;i<n;++i) cin>>word[i];
    char st;
    cin>>st;
    
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
        {
            string a=word[i];
            string b=word[j];
            
            for(int k=1;k<min(a.size(),b.size());++k)
            {
                if(a.substr(a.size()-k,k)==b.substr(0,k))
                {
                    g[i][j]=k;
                    break;
                }
            }
        }
        
    for(int i=0;i<n;++i)
    {
        if(word[i][0]==st) dfs(word[i],i);
    }
    
    cout<<ans<<endl;
    return 0;
}



------------------------ 0414 / 2021/  

也是回溯，以st为开始向下进行搜索




#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

const int N=25;

string word[N];
int n;
char st;

int g[N][N]; // 重合的长度最短，最后拼成的长度才最长
int use[N];

int res;

void dfs(string tmp, int last)
{
    res=max((int)tmp.size(), res);
    
    use[last]++;
    
    for(int i=0;i<n;++i){ // 搜索当前一直向下进行搜索
        if(g[last][i] && use[i] < 2) 
            dfs(tmp+ word[i].substr(g[last][i]) ,i);
    } // 搜索当前分支，如果搜到不能搜为止，就回溯，在后面将use--，恢复
    
    use[last]--;
}



int main()
{
    cin>>n;
    for(int i=0;i<n;++i) cin>>word[i];
    cin>>st;
    
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j){
            string a=word[i];
            string b=word[j];
            
            for(int k=1;k<min(a.size(), b.size()) ;++k){
                if(a.substr(a.size() -k, k) == b.substr(0, k)){
                    g[i][j]=k;
                    break;
                }
            }
        }
        
    
    for(int i=0;i<n;++i)
        if(word[i][0] == st) 
            dfs(word[i], i); // 搜索每个可能，然后更新全局的res
        
    cout<<res<<endl;
    
    return 0;
    
}



