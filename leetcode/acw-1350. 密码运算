1350. 密码运算

给定一个如下乘法算式：

      * * *
   x    * *
    -------
      * * *         
    * * *           
    -------
    * * * *
现在，给定 N 个 1∼9 之间的数字，请你在这些数字中选取合适的数字填入算式，代替 * 号，使得算式成立。

所给的数字可以在算式中出现多次。

算式中不能出现没有给出的数字。

请问，共有多少种不同的填法？

输入格式
第一行包含整数 N。

第二行包含 N 个整数，表示给定的数字，数据保证这 N 个数字互不相同。

输出格式
输出一个整数，表示可以使得算式成立的总填法数量。

数据范围
1≤N≤9
输入样例：
5
2 3 4 6 8
输出样例：
1
样例解释
唯一的使得算式成立的填法如下：

      2 2 2
    x   2 2
     ------
      4 4 4
    4 4 4
  ---------
    4 8 8 4
每个代替 * 号的数字均在给出数字之中，满足条件。

再看一组不满足条件的填法：

      2 2 2   <-- OK:  三个数字均在 {2, 3, 4, 6, 8} 之中
    x   2 3   <-- OK:  两个数字均在 {2, 3, 4, 6, 8} 之中
     ------
      6 6 6   <-- OK:  三个数字均在 {2, 3, 4, 6, 8} 之中
    4 4 4     <-- OK:  三个数字均在 {2, 3, 4, 6, 8} 之中
  ---------
    5 1 0 6   <-- NOT OK: 5,1,0 均不在 {2, 3, 4, 6, 8} 之中
    
    
    
------------------------ 2022/  /0111   yxc


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10;

bool st[N];

bool check_in(int x){
    while(x) {
        if(!st[x%10]) return false;
        x/=10;
    }
    
    return true;
}

bool check_len(int x, int l){
    return to_string(x).size() == l;
}

bool check(int a, int b){
    int c=a*(b%10);
    int d=a*(b/10);
    int e=a*b;
    
    if(!check_in(a) || !check_in(b) || !check_in(c) || !check_in(d) || !check_in(e)) return false;
    if(!check_len(a, 3) || !check_len(b, 2) || !check_len(d, 3) || !check_len(e, 4) || !check_len(c, 3)) return false;
    
    return true;
}

int main()
{
    int n;
    cin>>n;
    
    for(int i=0;i<n;++i){
        int x;cin>>x;
        st[x]=true;
    }
    
    int res=0;
    for(int i=100;i<=999;++i)
        for(int j=10;j<=99;++j){
            if(check(i, j)) res++;
        }
        
    cout<<res<<endl;
    return 0;
}

