1352. 虫洞
农夫约翰在周末进行高能物理实验的时候发生了一些意外，导致他的农场上出现了 N 个虫洞（N 是偶数）。

我们将农场视作一个二维平面，每个虫洞都位于其中的不同点上，也就是说所有虫洞的坐标 (x,y) 均不相同。

根据他的计算，这些虫洞将形成 N/2 个连接对。

例如，如果虫洞 A 和 B 成对连接，那么进入虫洞 A 的生物会从虫洞 B 出来，反之亦然。

这将引发很不愉快的后果。

假设虫洞 A(1,1) 和虫洞 B(3,1) 成对连接，奶牛贝茜从 (2,1) 位置开始沿 x 轴正向移动。

贝茜就会进入到虫洞 B 中，并从虫洞 A 处出来，然后再次移动到虫洞 B 中，以此类推，陷入无限循环。

约翰知道每个虫洞的具体坐标位置，同时知道贝茜会一直沿着 x 轴正向移动，但是她当前的位置约翰并不清楚。

贝茜在沿 x 轴正方向移动时，一旦遇到虫洞则必须进入。

现在请你计算，有多少种不同的虫洞配对方案，可以使得贝茜从某个点开始移动，能够陷入到无限循环之中。

输入格式
第一行包含整数 N，表示虫洞数量。

接下来 N 行，每行包含两个整数 x,y，表示一个虫洞的位置坐标。

输出格式
输出一个整数，表示能够使得贝茜陷入无限循环的虫洞配对方案的总数。

数据范围
2≤N≤12,
0≤x,y≤109
输入样例：
4
0 0
1 0
1 1
0 1
输出样例：
2
样例解释：
方案 1：(0,0) 与 (1,0) 配对，(0,1) 与 (1,1) 配对，贝茜从 (−1,0) 出发就可以陷入无限循环。

方案 2：(0,0) 与 (1,1) 配对，(1,0) 与 (0,1) 配对，贝茜从 (1,1) 处进入虫洞，即可陷入 (1,1)→(0,0)→(1,0)→(0,1)→(1,1)… 的无限循环。


--------------- 2022 / 0112   yxc



// to1[i] 第i个点的出边指向谁的
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 12;

int n;
bool st[N]; // dfs遍历用的数组
bool used[N][2], cur[N][2]; // 找环用的数组

struct Point{
    int x, y;
    bool operator<(const Point& t) const {
        if( y != t.y) return y < t.y;
        else return x < t.x;
    }
}p[N];

int to1[N];
int to2[N]; // 配对的点是多少

int res;

bool dfs_c(int a, int b){
    if(cur[a][b]) return true;
    if(used[a][b]) return false; // 如果当前不在环里，并且被别的路径搜索的，返回false，不存在环
    
    bool res=false;
    cur[a][b]=used[a][b]=true;
    
    if(b==0) { // a的入点
        if(dfs_c(to2[a], 1)) res=true;
    }else {
        // a的出点
        if(to1[a] != -1 && dfs_c(to1[a], 0)) res=true;
    }
    
    cur[a][b]=false;
    return res;
}

bool check(){ // 检查是否有环
    memset(used, 0, sizeof used);
    memset(cur, 0, sizeof cur);
    
    for(int i=0;i<n;++i){
        for(int j=0; j<2;++j){
            if(!used[i][j]){
                if(dfs_c(i, j)) return true;
            }
        }
    }
    
    return false;
}

void dfs(int u){
    if(u == n/2){
        if(check()) res++;
        return ;
    }
    
    for(int i=0;i<n;++i){
        if( !st[i]){
            for(int j=i+1;j<n;++j){
                if(!st[j]){
                    st[i]=st[j]=true;
                    to2[i]=j;
                    to2[j]=i;
                    dfs(u+1);
                    
                    to2[i]=to2[j]=-1;
                    st[i]=st[j]=false;
                }
                
                
            }
            
            break;
        }
    }
}

int main()
{
    cin>>n;
    for(int i=0;i<n;++i) cin>>p[i].x>>p[i].y;
    sort(p, p+n);
    
    memset(to1, -1, sizeof to1);
    memset(to2, -1, sizeof to2);
    
    for(int i=1;i<n;++i)
    {
        if(p[i].y == p[i-1].y) 
            to1[i-1]=i;
    }
    
    dfs(0);
    
    cout<<res<<endl;
    return 0;   
}




