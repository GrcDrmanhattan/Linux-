139. 回文子串的最大长度

如果一个字符串正着读和倒着读是一样的，则称它是回文的。

给定一个长度为 N 的字符串 S，求他的最长回文子串的长度是多少。

输入格式
输入将包含最多 30 个测试用例，每个测试用例占一行，以最多 1000000 个小写字符的形式给出。

输入以一个以字符串 END 开头的行表示输入终止。

输出格式
对于输入中的每个测试用例，输出测试用例编号和最大回文子串的长度（参考样例格式）。

每个输出占一行。

输入样例：
abcbabcbabcba
abacacbaaaab
END
输出样例：
Case 1: 13
Case 2: 6
---------------------------------   0326 / 2021/  yxc 


二分logn，然后遍历每个点作为中心点，On

时间Onlogn




#include<iostream>
#include<algorithm>
#include<cstring>


using namespace std;

const int N=2e6+10;
const int base=131;

typedef unsigned long long ull;


char s[N];
ull hl[N];
ull hr[N];
ull p[N];


ull get(ull h[], int l, int r)
{
    return h[r] - h[l-1] * p[r-l+1]; 
}


int main()
{
    int T=1;
    
    while(scanf("%s", s+1), strcmp(s+1, "END"))
    {
        int n=strlen(s+1);
        
        for(int i=n * 2;i>0; i-=2)
        {
            s[i] = s[i/2]; // 第i位置等于原来字母，
            s[i-1] = 'z' + 1; // 第i-1位置等于补充的分隔符
        }
        
        n = n*2;
        
        p[0]=1;
        for(int i=1, j=n; i<=n; ++i, --j)
        {
            hl[i] = hl[i-1] * base + s[i] - 'a' + 1; //  求正序哈希值
            hr[i] = hr[i-1] * base + s[j] - 'a' + 1; // 求逆序哈希值
            p[i] = p[i-1] * base;
        }
        
        // 遍历每个字符作为中间点，二分扩展左右的边界，最小为l， 最长为r
        
        int res=0;
        for(int i=1;i<=n;++i)
        {
            int l=0;
            int r=min(i-1 , n-i);// i向左最多i-1， 向右最多n-i位置
            
            // i-mid, ...i-1 , i i+1, .... i+mid
            // 但是i右侧是逆序所以要把坐标转换成逆序对应的坐标
            // i(正序) = n + 1 - i(逆序)
           // 逆序后大小会发生变化，所以还要交换一下
            
            while(l<r)
            {
                int mid=l+r+1>>1;
                if(get(hl, i-mid, i-1) != get(hr, n + 1 - (i+mid), n+1-(i+1))) r=mid-1;
                else l=mid;
            }
            
            // 最后二分出的长度l是包括分隔符的长度 ，还要去除掉分隔符
            if(s[i-l] <= 'z') res=max(res, l+1); // 最边界的是字母说明，字母比分隔符多一个
            else res=max(res, l);
        }
        
        printf("Case %d: %d\n", T++ , res);
        
    }
    
    return 0;
}



------------- 1024  -2021 

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 2e6+10;
const int base=131;

using ull=unsigned long long ;

ull p[N];
ull hl[N];
ull hr[N];
char s[N];

ull get(ull h[], int l, int r){
    return h[r]-h[l-1] * p[r-l+1];
}

int main()
{
    int t=1;
    while(scanf("%s", s+1), strcmp(s+1, "END")){
        int n=strlen(s+1);
        int res=0;
        
        for(int i=n*2;i>=1 ;i-=2){
            s[i] = s[i/2];
            s[i-1]='z'+1;
        }
        
        n*=2;
        
        p[0]=1;
        for(int i=1, j=n;i<=n;++i, --j){
            hl[i]=hl[i-1] * base + s[i]-'a'+1;
            hr[i]=hr[i-1] * base + s[j]-'a'+1; // 前i个字符的逆序哈希值
            p[i]=p[i-1] * base;
        }
        
        for(int i=1;i<=n;++i){
            int l=0; // 半径最小值
            int r=min(i-1, n-i);//半径最大值，1...i...n
            while(l<r){
                int mid=l+r+1>>1;
                if(get(hl, i-mid, i-1) != get(hr, n-(i+mid)+1, n-(i+1)+1)) r=mid-1; // 半径过长，要减少半径长度
                else l=mid;
            }
            // 最后求出的最长半径长度l是包含特殊字符
            // #a#b#c#d
            // 假设当b为中心，二分出半径是2，a#b#c,s[i-l]=a,则实际回文长度abc是三，就是2+1
            // 如果二分出半径是1，#b#, 则实际回文长度1，就是二分出的l
            if(s[i-l] <= 'z') res=max(res, l+1) ;// 如果最后一个是字母，字母比特殊字符多一个,则答案等于长度+1，要加一个字母的长度
            else res=max(res, l);
        }
        
        printf("Case %d: %d\n", t++ , res);
    }
    return 0;
}

