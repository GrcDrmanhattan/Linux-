165. 小猫爬山


翰翰和达达饲养了N只小猫，这天，小猫们要去爬山。

经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕>_<）。

翰翰和达达只好花钱让它们坐索道下山。

索道上的缆车最大承重量为W，而N只小猫的重量分别是C1、C2……CN。

当然，每辆缆车上的小猫的重量之和不能超过W。

每租用一辆缆车，翰翰和达达就要付1美元，所以他们想知道，最少需要付多少美元才能把这N只小猫都运送下山？

输入格式
第1行：包含两个用空格隔开的整数，N和W。

第2..N+1行：每行一个整数，其中第i+1行的整数表示第i只小猫的重量Ci。

输出格式
输出一个整数，表示最少需要多少美元，也就是最少需要多少辆缆车。

数据范围
1≤N≤18,
1≤Ci≤W≤108
输入样例：
5 1996
1
2
1994
12
29
输出样例：
2

####################################################   dfs剪枝

//从前向后依次枚举当前的猫放入哪个车上 dfs
//指数级别时间复杂度
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

const int N=20;

int n,m;
int w[N];
int sum[N];

int ans=N;//全局的最小值

void dfs(int u,int k)
{
    //最优性剪枝
    if(k>=ans) return ;//当前车的数目大于ans，肯定不合法
    
    if(u==n)
    {
        ans=k;
        return ;
    }
    
    for(int i=0;i<k;++i)//枚举k个车
    {
        if(sum[i]+w[u]<=m)//k可以放在第i个车，可行性剪枝
        {
            sum[i] += w[u];
            dfs(u+1,k);
            sum[i] -= w[u];//恢复现场
        }
    }
    
    //  新开一个车
    sum[k]=w[u];
    dfs(u+1,k+1);
    sum[k]=0;//恢复现场
}


int main()
{
    cin>>n>>m;
    for(int i=0;i<n;++i) cin>>w[i];
    
    //优化搜索顺序
    sort(w,w+n);
    reverse(w,w+n);//大的在前
    
    dfs(0,0);//当前搜到第0个猫，当前车的数目是0
    
    cout<<ans<<endl;
    return 0;

}


