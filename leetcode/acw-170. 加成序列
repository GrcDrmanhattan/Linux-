170. 加成序列

满足如下条件的序列 X（序列中元素被标号为 1、2、3…m）被称为“加成序列”：

X[1]=1
X[m]=n
X[1]<X[2]<…<X[m−1]<X[m]
对于每个 k（2≤k≤m）都存在两个整数 i 和 j （1≤i,j≤k−1，i 和 j 可相等），使得 X[k]=X[i]+X[j]。
你的任务是：给定一个整数 n，找出符合上述条件的长度 m 最小的“加成序列”。

如果有多个满足要求的答案，只需要找出任意一个可行解。

输入格式
输入包含多组测试用例。

每组测试用例占据一行，包含一个整数 n。

当输入为单行的 0 时，表示输入结束。

输出格式
对于每个测试用例，输出一个满足需求的整数序列，数字之间用空格隔开。

每个输出占一行。

数据范围
1≤n≤100
输入样例：
5
7
12
15
77
0
输出样例：
1 2 4 5
1 2 4 6 7
1 2 4 8 12
1 2 4 5 10 15
1 2 4 8 9 17 34 68 77


----------------  0419/  2021/  yxc 

迭代加深


#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int tmp[N];

bool dfs(int u, int md)
{
    if(u > md) return false;
    if(tmp[u-1] == n) return true;
    
    bool st[N]={0};
    
    for(int i=u-1;i>=0;--i)
        for(int j=i;j>=0;--j)
        {
            int s=tmp[i] + tmp[j];
            if(st[s] || s>n || s<= tmp[u-1]) continue;
            
            st[s]=true;
            tmp[u]=s;
            if(dfs(u+1, md)) return true;
        }
        
    return false;
}

int main()
{
    tmp[0]=1;
    while(cin>>n, n)
    {
        int mdepth=1;
        while(!dfs(1 , mdepth)) mdepth++;
        
        for(int i=0;i<mdepth;++i) cout<<tmp[i]<<' ';
        cout<<endl;
    }
    
    return 0;
}



-------------------------- 0419  //2021 

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
int tmp[N];

bool dfs(int u, int md)
{
    if(u==md) return tmp[u-1] == n;
    
    bool st[N]={0};
    
    for(int i=u-1;i>=0;--i)
        for(int j=i;j>=0;--j)
        {
            int s=tmp[i]+tmp[j];
            if(!st[s] && s<=n && s>tmp[u-1])
            {
                st[s]=true;
                tmp[u]=s;
                if(dfs(u+1, md)) return true;
            }
        }
        
    return false;
}

int main()
{
    
    while(cin>>n, n)
    {
        tmp[0]=1;
        int md=1;
        while(!dfs(1, md)) md++; // 从序列的第一个数开始搜索
        
        for(int i=0;i<md;++i) cout<<tmp[i]<<' ';
        cout<<endl;
    }
    
    return 0;
}




