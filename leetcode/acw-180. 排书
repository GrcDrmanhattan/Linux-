180. 排书

给定 n 本书，编号为 1∼n。

在初始状态下，书是任意排列的。

在每一次操作中，可以抽取其中连续的一段，再把这段插入到其他某个位置。

我们的目标状态是把书按照 1∼n 的顺序依次排列。

求最少需要多少次操作。

输入格式
第一行包含整数 T，表示共有 T 组测试数据。

每组数据包含两行，第一行为整数 n，表示书的数量。

第二行为 n 个整数，表示 1∼n 的一种任意排列。

同行数之间用空格隔开。

输出格式
每组数据输出一个最少操作次数。

如果最少操作次数大于或等于 5 次，则输出 5 or more。

每个结果占一行。

数据范围
1≤n≤15
输入样例：
3
6
1 3 4 6 2 5
5
5 4 3 2 1
10
6 8 5 3 4 7 2 9 1 10
输出样例：
2
3
5 or more
-------------------------------- 0422  / /2021/  yxc 

ida*


// 每次搜索的时候有多少种不同选择呢
// 将区间lr放到k位置后面

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 15;

int n;
int q[N];
int w[N][N];

int f()  // 估值函数，当后一个不等于前面的数加一，res++
{
    int res=0;
    for(int i=0;i+1< n;++i)
        if(q[i+1] != q[i] +1)
            res++;
    return (res + 2) /3;
}

bool dfs(int u, int md)
{
    if(u + f() > md) return false;
    if(f() == 0) return true;
    
    for(int len= 1; len <=n ;++len)
        for(int l=0; l+len -1 <n;++l)
        {
            int r=l+len-1;
            for(int k=r+1;k<n;++k)
            {
                memcpy(w[u], q, sizeof(q));
                
                int y=l;
                int x;
                for(int x=r+1;x<=k;x++, y++) q[y]=w[u][x];  // l r  k
                for(int x=l;x<=r;x++, y++) q[y]=w[u][x];
                if(dfs(u+1, md)) return true;
                memcpy(q, w[u], sizeof q);
            }
        }
    
    return false;
}


int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        cin>>n;
        for(int i=0;i<n;++i) cin>>q[i];
        int md=0;
        
        while(md < 5 && !dfs(0, md)) md++;
        
        if(md >=5 ) puts("5 or more");
        else cout<<md<<endl;
        
    }
    
    return 0;
}


