240. 食物链
动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。

A吃B， B吃C，C吃A。

现有N个动物，以1－N编号。

每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这N个动物所构成的食物链关系进行描述：

第一种说法是”1 X Y”，表示X和Y是同类。

第二种说法是”2 X Y”，表示X吃Y。

此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。

当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

1） 当前的话与前面的某些真的话冲突，就是假话；
2） 当前的话中X或Y比N大，就是假话；
3） 当前的话表示X吃X，就是假话。

你的任务是根据给定的N和K句话，输出假话的总数。

输入格式
第一行是两个整数N和K，以一个空格分隔。

以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。

若D=1，则表示X和Y是同类。

若D=2，则表示X吃Y。

输出格式
只有一个整数，表示假话的数目。

数据范围
1≤N≤50000,
0≤K≤100000
输入样例：
100 7
1 101 1 
2 1 2
2 2 3 
2 3 3 
1 1 3 
2 3 1 
1 5 5
输出样例：
3



---------------------------------------- 0107 /2021 //yxc



// 将问题转化为并查集的问题，通过每个节点到根节点到距离不同，区分节点之间的关系，因为三个一循环，所以以距离%3作为分级



#include<iostream>

using namespace std;

const int N=5e4+10;

int n,k;
int p[N],d[N]; // d[xx] 表示xx到父节点的距离,find结束后表示到根节点到距离， 路径压缩累计到根节点到距离


int find(int x)
{
    if(p[x] != x) 
    {
        int tmp=find(p[x]);
        
        d[x] += d[p[x]];
        p[x] = tmp;
    }
    
    return p[x];
}


int main()
{
    cin>>n>>k;
    for(int i=1;i<=n;++i) p[i]=i;
    
    int res=0;
    
    while(k--)
    {
        int f,x,y;
        cin>>f>>x>>y;
        
        int px=find(x);
        int py=find(y);
        
        if(x>n || y>n) res++;
        else
        {
            if(f==1)
            {
                if(px==py && (d[x] - d[y])%3 != 0) res++;//在同一个集合，但到根节点距离%3不等,说明不是同类，假话
                else if(px!=py)
                {
                    // 不在同一个集合，
                    p[px]=py; // 放入同一个集合
                    d[px] = d[y]-d[x]; // 让距离%3相等
                }
            }
            else
            { // x吃y
                if(px == py && (d[x]-1-d[y])%3 != 0) res++;
                else if(px != py)
                {
                    p[px]=py;
                    d[px]=1+d[y]-d[x]; // 构造x吃y的距离
                }
            }
        }
        
    }
    
    
    cout<<res<<endl;  
    return 0;
}


