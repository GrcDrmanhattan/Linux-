272. 最长公共上升子序列

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。

小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。

小沐沐说，对于两个数列 A 和 B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。

奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。

不过，只要告诉奶牛它的长度就可以了。

数列 A 和 B 的长度均不超过 3000。

输入格式
第一行包含一个整数 N，表示数列 A，B 的长度。

第二行包含 N 个整数，表示数列 A。

第三行包含 N 个整数，表示数列 B。

输出格式
输出一个整数，表示最长公共上升子序列的长度。

数据范围
1≤N≤3000,序列中的数字均不超过 231−1。

输入样例：
4
2 2 1 3
2 1 2 3
输出样例：
2


----------------------- 0428  / 2021/  yxc   超时代码


/*
f[i][j] 表示集合，所有由第一个序列的前i个字母，第二个序列的前j个字母构成，并且以bj结尾的公共上生子序列，这样的集合的长度的最大值

划分为两类，所有包含ai的，不包含ai的

不包含ai的f[i-1][j]
包含ai的是根据bj序列倒数第二个字母划分k类，f[i][k] +1 ，又因为结尾是bj，所以ai和bj要相等

*/
// 如果ai和bj每个都相等，则最坏On^3



#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 3010;

int n;
int a[N];
int b[N];
int f[N][N];

int res;

int main()
{
    cin>>n;
    for(int i=1;i<=n;++i) cin>>a[i];
    for(int i=1;i<=n;++i) cin>>b[i];
    
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
        {
            
            f[i][j]=f[i-1][j];// 
            
            // f[i][1]=1;
            if(a[i]== b[j]){
                f[i][j]=max(f[i][j], 1); // 倒数第二个为空的情况
                
                for(int k=1;k<j;++k){ // 不为空划分k类
                    if(b[k] < b[j])
                        f[i][j]=max(f[i][j], f[i][k]+1);
                }
            }
        }
        
    
    for(int i=1;i<=n;++i) res=max(res, f[n][i]);
    cout<<res<<endl;
    
    return 0;
}




------------------ 优化  理论最坏On2，代码等价变形





