341. 最优贸易

C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。

任意两个城市之间最多只有一条道路直接相连。

这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。

C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。

但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 C 国旅游。

当他得知“同一种商品在不同城市的价格可能会不同”这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚一点旅费。

设 C 国 n 个城市的标号从 1∼n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。

在旅游的过程中，任何城市可以被重复经过多次，但不要求经过所有 n 个城市。

阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。

因为阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

现在给出 n 个城市的水晶球价格，m 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。

请你告诉阿龙，他最多能赚取多少旅费。

注意：本题数据有加强。

输入格式
第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。

第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。

接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。

如果 z=1，表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市 y 之间的双向道路。

输出格式
一个整数，表示答案。

数据范围
1≤n≤100000,
1≤m≤500000,
1≤各城市水晶球价格≤100
输入样例：
5 5
4 3 5 6 1
1 2 1
1 4 1
2 3 2
3 5 1
4 5 2
输出样例：
5


-------------------------- 0529 / 2021/  


// dp是拓扑图无环上的最短路问题
// 如果dp依赖关系不具有拓扑序，存在环的，可以转换为最短路求解和高斯消元
// 本题看选择dj还是spfa，
// dj的核心是每次从堆中取出最小值，如果可以判断不会被其他点更新，就可以dj，如果可以被其他更新就不能dj算法

// 以k分界 ，分别计算k之前买入的最小值，k之后卖出的最大值

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010, M=2e6+10;

int n ,m;
int hs[N]; // 正向边
int ht[N]; // 反向边
int w[N] ; // 点的权重 范围是N
int ne[M];
int e[M];
int idx;

bool st[N];

int q[N];
int dmin[N];
int dmax[N];

void add(int h[], int a, int b)
{
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

void spfa(int h[], int dis[], int type)
{
    int hh=0;
    int tt=1;
    if(type==1){
        memset(dis, -0x3f, sizeof dmax );
        dis[n]=w[n];
        q[0]=n;
    }else{
        memset(dis, 0x3f, sizeof dmin);
        dis[0]=w[1];
        q[0]=1;
    }
    
    while(hh != tt)
    {
        int t=q[hh++];
        if(hh==N) hh=0;
        st[t]=false;
        
        for(int i=h[t]; i!=-1; i=ne[i]){
            int j=e[i];
            
            if(type == 0 && dis[j] > min(dis[t], w[j]) || type==1 && dis[j] < max(dis[t], w[j])){
                if(type==0){
                    dis[j]=min(dis[t], w[j]);
                }
                else dis[j]=max(dis[t], w[j]);
                
                if(!st[j]){
                    q[tt++]=j;
                    if(tt==N) tt=0;
                    st[j]=true;
                }
            }
        }
    }
}


int main()
{
    scanf("%d%d", &n, &m);
    for(int i=1;i<=n;++i) scanf("%d", &w[i]);
    
    memset(hs, -1, sizeof hs);
    memset(ht, -1, sizeof ht);
    
    while (m -- ){
        int a, b, type;
        scanf("%d%d%d", &a, &b ,&type);
        add(hs, a, b);
        add(ht, b, a);
        
        if(type == 2) {
            add(hs, b, a);
            add(ht, a, b);
        }
    }
    
    spfa(hs, dmin, 0); // 0 求最小值, hs正向
    spfa(ht, dmax, 1); // 1 求最大值 ht逆向求最大值
    
    int res=0;
    
    for(int i=1;i<=n;++i) res=max(res, dmax[i]- dmin[i]);
    
    printf("%d\n", res);
    return 0;
}


