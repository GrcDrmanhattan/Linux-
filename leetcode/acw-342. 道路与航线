342. 道路与航线
农夫约翰正在一个新的销售区域对他的牛奶销售方案进行调查。

他想把牛奶送到 T 个城镇，编号为 1∼T。

这些城镇之间通过 R 条道路 (编号为 1 到 R) 和 P 条航线 (编号为 1 到 P) 连接。

每条道路 i 或者航线 i 连接城镇 Ai 到 Bi，花费为 Ci。

对于道路，0≤Ci≤10,000;然而航线的花费很神奇，花费 Ci 可能是负数(−10,000≤Ci≤10,000)。

道路是双向的，可以从 Ai 到 Bi，也可以从 Bi 到 Ai，花费都是 Ci。

然而航线与之不同，只可以从 Ai 到 Bi。

事实上，由于最近恐怖主义太嚣张，为了社会和谐，出台了一些政策：保证如果有一条航线可以从 Ai 到 Bi，那么保证不可能通过一些道路和航线从 Bi 回到 Ai。

由于约翰的奶牛世界公认十分给力，他需要运送奶牛到每一个城镇。

他想找到从发送中心城镇 S 把奶牛送到每个城镇的最便宜的方案。

输入格式
第一行包含四个整数 T,R,P,S。

接下来 R 行，每行包含三个整数（表示一个道路）Ai,Bi,Ci。

接下来 P 行，每行包含三个整数（表示一条航线）Ai,Bi,Ci。

输出格式
第 1..T 行：第 i 行输出从 S 到达城镇 i 的最小花费，如果不存在，则输出 NO PATH。

数据范围
1≤T≤25000,
1≤R,P≤50000,
1≤Ai,Bi,S≤T
输入样例：
6 3 3 4
1 2 5
3 4 5
5 6 10
3 5 -100
4 6 -100
1 3 -10
输出样例：
NO PATH
NO PATH
5
0
-95
-100


--------------------- 0528  /2021/  yxc 


// spfa被卡，Okm，k是常数，最坏是Onm为bellford算法
// 所有边权是非负的可以，堆优化dj算法，mlogn
// 按照拓扑序更新每个点，可以保证到每个点时最短距离可以求，时间是线性的，边权可以正负
// 单源最短路和拓扑排序的结合

// 时间瓶颈要看dj算法，每个团内dj 时间m1logn1+m2logn2 +... 扩大为(m1+m2+m3..)logn 就是mlgon

#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;
const int N = 25010 , M=150010;
const int inf =0x3f3f3f3f;

#define x first
#define y second
typedef pair<int, int> PII;


int n, mr,mp, S;

int h[N];
int e[M];
int ne[M];
int w[M];
int idx;

int din[N];// 入度
int id[N];// 每个点对应的连通块的id
int cnt; // 连通块的个数
vector<int> block[N]; // 每个连通块包含的点

int dis[N];
queue<int> q;
bool st[N];

void add(int a, int b ,int c)
{
    e[idx]=b;
    w[idx]=c;
    ne[idx]=h[a];
    h[a]=idx++;
}

void dfs(int u ,int cur) // cur当前的连通块的id
{
    id[u]=cur;
    block[cur].push_back(u);
    
    for(int i=h[u];i!=-1;i=ne[i]){ //遍历当前点的邻居
        int j=e[i];
        if(!id[j]) dfs(j, cur);
    }
}


void dj(int bid) // 堆优化dj算法
{
    priority_queue<PII, vector<PII> , greater<PII>> hp;
    
    for(auto x:block[bid]) hp.push({dis[x], x});
    
    while(hp.size()){
        auto t=hp.top();
        hp.pop();
        
        int v=t.y;
        // int d=t.x;
        if(st[v]) continue;
        st[v]=true;
        
        for(int i=h[v];i!=-1;i=ne[i]){
            int j=e[i];
            if(dis[j] > dis[v] + w[i]){
                
                dis[j]=dis[v] + w[i];
                if(id[j] == id[v]) hp.push({dis[j], j});
            }
            
            if(id[j] != id[v] && --din[id[j]] == 0) q.push(id[j]);
        }
    }
}

void topsort()
{
    memset(dis, 0x3f ,sizeof dis);
    dis[S]=0;
    
    for(int i=1;i<=cnt;++i)
        if(!din[i])
            q.push(i); // 将入度为0的块id放入队列
            
    while(q.size()){
        int t=q.front();
        q.pop();
        dj(t);
    }
}

int main()
{
    scanf("%d%d%d%d", &n, &mr, &mp, &S);
    memset(h, -1, sizeof h);
    
    while(mr -- ){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
        add(b, a, c);
    }
    
    for(int i=1;i<=n;++i){
        if(!id[i])
            dfs(i, ++cnt);
    }
    
    while(mp -- ){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b ,c);
        din[id[b]]++;
    }
    
    topsort();
    
    for(int i=1;i<=n;++i){
        if(dis[i] > inf/ 2) puts("NO PATH");
        else printf("%d\n", dis[i]);
    }
    
    return 0;
}


