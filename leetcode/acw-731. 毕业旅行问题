731. 毕业旅行问题

小明目前在做一份毕业旅行的规划。

打算从北京出发，分别去若干个城市，然后再回到北京，每个城市之间均乘坐高铁，且每个城市只去一次。

由于经费有限，希望能够通过合理的路线安排尽可能的省些路上的花销。

给定一组城市和每对城市之间的火车票的价钱，找到每个城市只访问一次并返回起点的最小车费花销。

注意：北京为1号城市。

输入格式
城市个数n。

城市间的车票价钱n行n列的矩阵 m[n][n]

输出格式
输出一个整数，表示最小车费花销。

数据范围
1<n≤20,包括北京
车票价格均不超过1000元。
 输入样例：
4
0 2 6 5
2 0 4 4
6 4 0 2
5 4 2 0
输出样例：
13
说明
共4个城市，城市1和城市1的车费为0，城市1和城市2之间的车费为2，城市1和城市3之间的车费为6，城市1和城市4之间的车费为5，以此类推。

假设任意两个城市之间均有单程票可买，且价格均在1000元以内，无需考虑极端情况。

###############################################################################
#include<iostream>
#include<algorithm>
#include<cstring>

const int N=20,M=1<<N;
using namespace std;

int n;
int g[N][N];
int dp[M][N];//到状态n，路径中包含m的所有集合的最小值
//这里用0表示第一个点，0到n-1个共n个点

int main()//状态压缩dp，状态总数*每次计算复杂度=2^20第一维 * 20第二维 *每次枚举最多20=4e8
{
    cin>>n;
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
            cin>>g[i][j];
            
    memset(dp,0x3f,sizeof(dp));
    dp[1][0]=0;
    
    for(int i=0;i< 1<<n;++i)
        for(int j=0;j<n;++j)
        {
            if(i>>j & 1)//  路径到达j
            {
                for(int k=0;k<n;++k)//遍历经过k到达j
                {
                    if((i-(1<<j)) >> k &1) //状态要先去除j的，然后看是否到达k
                    {
                        dp[i][j]=min(dp[i][j],dp[i-(1<<j)][k]+g[k][j]);
                    }
                }
            }
        }
            
    int res=1e9;
    for(int i=0;i<n;++i)
    {
        res=min(res,dp[(1<<n)-1][i]+g[i][0]);//第一个点设为0
    }
    
    cout<<res<<endl;
    return 0;
}

