891. Nim游戏

给定 n 堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

输入格式
第一行包含整数 n。

第二行包含 n 个数字，其中第 i 个数字表示第 i 堆石子的数量。

输出格式
如果先手方必胜，则输出 Yes。

否则，输出 No。

数据范围
1≤n≤105,
1≤每堆石子数≤109
输入样例：
2
2 3
输出样例：
Yes



------------------------------------- 0331/  2021  /  yxc 


// 先手必胜状态：是走过一步后，变成了先手必败状态，也就是留给对方一个先手必败，自己就是必胜
// 先手必败状态：走一步后，走不到任何必败状态，也就是不能找到使得对方必败的方案，自己就是必败

// a1^a2^...an == 0 先手必败状态，！= 0 表示先手必胜
// 1.   证明如果异或和不是0，就可以从中拿走一些石头使得异或和变为0，也就是变为必败态，自己则是必胜态

// 假设a1^a2^a3^....^an=x
// 假设x的最高的1位置是第k位
// 则a1到an之间至少存在一个数ai的第k位是1，因为如果不存在则异或和是0，矛盾
// 所以可以将这个数拿走一些变为ai ^ x, 则a1^a2^...ai^x^....an= x ^ x = 0
// (ai ^ x < ai) 因为都是第k位是1，但是ai在第k位之前还有数字，

// 2 。证明 a1^a2^a3^....^an=0是必败，也就是证明无论怎么拿数字，剩下的异或和都不等于0（剩下的都是对手必胜）则自己必败
/*
    反证法



*/


#include<iostream>
#include<algorithm>

using namespace std;


int n;

int res=0;

int main()
{
    cin>>n;
    while(n--)
    {
        
        int x;
        cin>>x;
        res ^=x;
    }
    
    if(res) puts("Yes");
    else puts("No");
    
    return 0;
}


