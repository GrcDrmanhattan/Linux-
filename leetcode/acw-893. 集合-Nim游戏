893. 集合-Nim游戏

给定 n 堆石子以及一个由 k 个不同正整数构成的数字集合 S。

现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，每次拿取的石子数量必须包含于集合 S，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。

输入格式
第一行包含整数 k，表示数字集合 S 中数字的个数。

第二行包含 k 个整数，其中第 i 个整数表示数字集合 S 中的第 i 个数 si。

第三行包含整数 n。

第四行包含 n 个整数，其中第 i 个整数表示第 i 堆石子的数量 hi。

输出格式
如果先手方必胜，则输出 Yes。

否则，输出 No。

数据范围
1≤n,k≤100,
1≤si,hi≤10000
输入样例：
2
2 5
3
2 4 7
输出样例：
Yes


--------------------------------- 0331/  2021/  yxc 


/*
终止状态的sg函数值定义为0
其余的sg函数定义为不能到达的最小的自然数，从0开始

mex操作返回集合里没有出现的最小的自然数（从0开始

*/


#include<iostream>
#include<algorithm>
#include<cstring>
#include<unordered_set>

using namespace std;

const int N=110;
const int M=10010;

int n, k;

int s[N];
int f[M];


int sg(int x) // sg函数
{
    if(f[x] != -1) return f[x];
    
    unordered_set<int> mp;
    
    for(int i=0;i<k;++i)
    {
        int tmp=s[i];
        if(x >= tmp) mp.insert(sg(x-tmp)); // 如果当前数目大于可以拿的数目tmp，就将拿走tmp后余下的加入哈希表
    }
    
    // 寻找最小的没有出现的自然数
    for(int i=0;;i++)
    {
        if(!mp.count(i)) 
            return f[x]=i;
    }
    
}


int main()
{
    cin>>k;
    for(int i=0;i<k;++i) cin>>s[i];
    
    cin>>n;
    memset(f, -1 ,sizeof(f));
    
    int res=0;
    for(int i=0;i<n;++i)
    {
        int x;
        cin>>x;
        res ^= sg(x);
    }
    
    
    if(res) puts("Yes");
    else puts("No");
    
    return 0;
}


----------------------- 0331

 
#include<iostream>
#include<cstring>
#include<unordered_set> 

using namespace std;

const int N=1010;
const int M=10010;

int n,k;
int s[N];
int f[M]; // 存储没出现的最小值


int sg(int x)
{
    if(f[x] != -1) return f[x];
    
    unordered_set<int> mp; // 存储每个点的sg值，终点的sg为0， 存储每个局面可以到的局面
    for(int i=0;i<k;++i)
    {
        int tmp=s[i];
        if(x>=tmp) mp.insert(sg(x-tmp));
    }
    
    for(int i=0;;i++)
    {
        if(!mp.count(i))
        {
            f[x]=i;
            return f[x]; // 返回起点x对应的没有出现的最小的自然数
        }
    }
}



int main()
{
    cin>>k;
    for(int i=0;i<k;++i) cin>>s[i];
    
    memset(f, -1 ,sizeof(f));
    cin>>n;
    
    int res=0;
    
    for(int i=0;i<n;++i)
    {
        int x;
        cin>>x;
        res ^= sg(x); // 将每个起点的sg值进行异或和
    }
    
    if(res) puts("Yes");
    else puts("No");
    
    return 0;
}



