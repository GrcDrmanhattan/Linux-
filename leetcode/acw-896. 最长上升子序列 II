896. 最长上升子序列 II

给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。

输入格式
第一行包含整数 N。

第二行包含 N 个整数，表示完整序列。

输出格式
输出一个整数，表示最大长度。

数据范围
1≤N≤100000，
−109≤数列中的数≤109
输入样例：
7
3 1 2 1 8 5 6
输出样例：
4


----------------------- 0427// 2021/  yxc 



// n个数，每个数都要二分找到接入的序列的位置，时间Onlogn
// n范围过大，所以不能用n2的dp求解



#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5+10;

int n;
int a[N];
int q[N];// 存储每种长度的序列的结尾最小值

int main()
{
    cin >> n;
    for(int i=0;i<n;++i) cin>>a[i];
    
    int len=0;
    q[0]=-2e9;
    
    for (int i = 0; i < n; i ++ )
    {
        int l=0;
        int r=len;
        while(l<r){ // 对每个元素二分一下大于等于当前元素的最小的数，然后将当前数放到二分的长度的序列的后面
            int mid=l+r+1>>1;
            if(q[mid] < a[i]) l=mid;
            else r=mid-1;
        }
        
        len=max(len, r+1);
        q[r+1]=a[i]; // 因为放入一个数长度增加了，所以更新下一个长度序列的结尾的最小值
    }
    
    cout << len<<endl;
    return 0;
    
}




