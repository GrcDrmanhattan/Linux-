903. 昂贵的聘礼

年轻的探险家来到了一个印第安部落里。

在那里他和酋长的女儿相爱了，于是便向酋长去求亲。

酋长要他用 10000 个金币作为聘礼才答应把女儿嫁给他。

探险家拿不出这么多金币，便请求酋长降低要求。

酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要 8000 金币。如果你能够弄来他的水晶球，那么只要 5000 金币就行了。”

探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。

探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。

不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。

探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。

另外他要告诉你的是，在这个部落里，等级观念十分森严。

地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。

他是一个外来人，所以可以不受这些限制。

但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。

因此你需要在考虑所有的情况以后给他提供一个最好的方案。

为了方便起见，我们把所有的物品从 1 开始进行编号，酋长的允诺也看作一个物品，并且编号总是 1。

每个物品都有对应的价格 P，主人的地位等级 L，以及一系列的替代品Ti和该替代品所对应的”优惠” Vi。

如果两人地位等级差距超过了 M，就不能”间接交易”。

你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。

输入格式
输入第一行是两个整数 M，N，依次表示地位等级差距限制和物品的总数。

接下来按照编号从小到大依次给出了 N 个物品的描述。

每个物品的描述开头是三个非负整数 P、L、X，依次表示该物品的价格、主人的地位等级和替代品总数。

接下来 X 行每行包括两个整数 T 和 V，分别表示替代品的编号和”优惠价格”。

输出格式
输出最少需要的金币数。

数据范围
1≤N≤100,
1≤P≤10000,
1≤L,M≤N,
0≤X<N
输入格式
1 4
10000 3 2
2 8000
3 5000
1000 2 1
4 200
3000 2 1
4 200
50 2 0
输出格式
5250


----------------------- 0526 / 2021/  yxc 

#include <iostream>
#include <cstring>
#include <algorithm>
const int N = 110;
const int inf = 0x3f3f3f3f;

using namespace std;

int m, n;
int w[N][N];
int dis[N];
bool st[N];
int level[N];

int dj(int l, int r)
{
    memset(dis, 0x3f,sizeof dis);
    memset(st, 0, sizeof st);
    
    dis[0]=0;
    
    for(int i=1;i<=n;++i)
    {
        int t=-1;
        for(int j=0;j<=n;++j)
            if(!st[j] && (t==-1 || dis[t] > dis[j]))
                t=j;
                
        st[t]=true;
        
        for(int j=1;j<=n;++j){
            if(level[j] >= l && level[j] <= r)
                dis[j]=min(dis[j], dis[t] + w[t][j]);
        }
    }
    
    return dis[1];
}

int main()
{
    cin>>m>>n;
    memset(w, 0x3f , sizeof w);
    
    for(int i=1;i <=n;++i) w[i][i]=0;
    
    for(int i=1;i<=n;++i){
        int price ;
        int cnt;
        cin>>price>>level[i]>>cnt;
        w[0][i]=min(price, w[0][i]); // 0 号物品是虚拟源点 w[0][i]相当于直接购买的价格
        
        while(cnt--){
            int id;
            int cost;
            cin>>id>>cost;
            w[id][i]=min(cost, w[id][i]); // 使用替换的去购买物品i的花费
        }
        
    }
    
    int res=inf;
    for(int i=level[1]-m;i<=level[1];++i) res=min(res, dj(i, i+m)); // 枚举区间的起点
    
    cout<<res<<endl;
    return 0;
}



---------------- 0526  

#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 110;
const int inf = 0x3f3f3f3f;

int n,m;
int w[N][N];
int level[N];
int dis[N];
bool st[N];

int dj(int l, int r)
{
    memset(dis, 0x3f, sizeof dis);
    memset(st, 0 ,sizeof st);
    dis[0]=0;
    
    for(int i=1;i<=n;++i)
    {
        int t=-1;
        for(int j=0;j<=n;++j)
            if(!st[j] && (t==-1 || dis[t] > dis[j]))
                t=j;
                
        st[t]=true;
        
        for(int j=1;j<=n;++j)
            if(level[j] >= l && level[j] <= r)
                dis[j]=min(dis[j], dis[t] + w[t][j]);
                
    }
    
    return dis[1];
}

int main()
{
    cin>>m>>n;
    memset(w, 0x3f, sizeof w);
    for(int i=1;i<=n;++i) w[i][i]=0;
    
    for(int i=1;i<=n;++i){
        int price;
        int cnt;
        cin>>price>>level[i]>>cnt;
        w[0][i]=min(w[0][i], price);
        
        while(cnt--){
            int id;
            int cost;
            cin>>id>>cost;
            w[id][i]=min(w[id][i], cost);
        }
    }
    
    int res=inf;
    for(int i=level[1]-m;i<=level[1];++i) res=min(res, dj(i, i+m));
    cout<<res<<endl;
    
    return 0;
}


