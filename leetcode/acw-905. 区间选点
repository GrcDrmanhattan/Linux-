905. 区间选点
给定N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。

输出选择的点的最小数量。

位于区间端点上的点也算作区间内。

输入格式
第一行包含整数N，表示区间数。

接下来N行，每行包含两个整数ai,bi，表示一个区间的两个端点。

输出格式
输出一个整数，表示所需的点的最小数量。

数据范围
1≤N≤105,
−109≤ai≤bi≤109

样例
输入样例：
3
-1 1
2 4
3 5
输出样例：
2

###############################################################################  贪心算法

#include<iostream>
#include<algorithm>

using namespace std;

const int N=1e5+10;

struct Range
{
  int l,r;
  bool operator< (const Range &w)const 
  {
      return r<w.r;
  }
}range[N];

int n;

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;++i)
    {
        int l,r;
        
        scanf("%d%d",&l,&r);
        range[i]={l,r};
        
    }
    
    sort(range,range + n);//按右端点排序
    
    int res=0;
    int ed=-2e9;//上一个点的下标
    
    for(int i=0;i<n;++i)
    {
        if(range[i].l>ed)//每次选择右端点，如果没有覆盖当前节点，就更新为右端点
        {
            res++;
            ed = range[i].r;
        }
    }
    
    printf("%d\n",res);
    
    return 0;
}

-------------------- 2022 / 0903   

贪心
1 按照区间右端点给每个区间排序
2 然后从每个区间选择一个点，选择右端点，因为这样覆盖的区间可能会大一些，
   如果当前区间包括这个点，pass这个区间，否则从当前区间选择点
   
   
#include<iostream>
#include<algorithm>

using namespace std;

const int N=1e5+10;

int n;
struct Range{
    int l, r;
    bool operator<(const Range &w ) const{
        return r<w.r;
    } 
}range[N];

int main()
{
    cin>>n;
    for(int i=0;i<n;++i){
        int l, r;
        cin>>l>>r;
        range[i]={l,r};
    }
    
    sort(range, range+n);
    
    int  res=0;
    int ed=-2e9;
    
    for(int i=0;i<n;++i){
        if(range[i].l > ed){
            res++;
            ed=range[i].r;
        }
    }
    
    cout<<res<<endl;
    return 0;
}

