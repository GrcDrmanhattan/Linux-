920. 最优乘车

H  城是一个旅游胜地，每年都有成千上万的人前来观光。

为方便游客，巴士公司在各个旅游景点及宾馆，饭店等地都设置了巴士站并开通了一些单程巴士线路。

每条单程巴士线路从某个巴士站出发，依次途经若干个巴士站，最终到达终点巴士站。

一名旅客最近到 H 城旅游，他很想去 S 公园游玩，但如果从他所在的饭店没有一路巴士可以直接到达 S 公园，则他可能要先乘某一路巴士坐几站，再下来换乘同一站台的另一路巴士，这样换乘几次后到达 S 公园。

现在用整数 1,2,…N 给 H 城的所有的巴士站编号，约定这名旅客所在饭店的巴士站编号为 1，S 公园巴士站的编号为 N。

写一个程序，帮助这名旅客寻找一个最优乘车方案，使他在从饭店乘车到 S 公园的过程中换乘的次数最少。

输入格式
第一行有两个数字 M 和 N，表示开通了 M 条单程巴士线路，总共有 N 个车站。

从第二行到第 M+1 行依次给出了第 1 条到第 M 条巴士线路的信息，其中第 i+1 行给出的是第 i 条巴士线路的信息，从左至右按运行顺序依次给出了该线路上的所有站号，相邻两个站号之间用一个空格隔开。

输出格式
共一行，如果无法乘巴士从饭店到达 S 公园，则输出 NO，否则输出最少换乘次数，换乘次数为 0 表示不需换车即可到达。

数据范围
1≤M≤100,
1≤N≤500
输入样例：
3 7
6 7
4 7 3 6
2 1 3 5
输出样例：
2

---------------------- 0524 / 2021/  yxc 

建图 边权是1
bfs就饿可以

#include <iostream>
#include <cstring>
#include <algorithm>
#include <sstream>

using namespace std;
const int N = 510;

int n,m;
bool g[N][N]; // 有边就是1
int dis[N];
int stop[N];//站牌
int q[N];

void bfs()
{
    int hh=0;
    int tt=0;
    memset(dis, 0x3f, sizeof dis);
    
    q[0]=1;
    dis[1]=0;
    
    while(hh <= tt)
    {
        int t=q[hh++];
        for(int j=1;j<=n;++j){
            if(g[t][j] && dis[j] > dis[t] +1){
                dis[j] = dis[t] + 1;
                q[++tt]= j;
            }
        }
    }
}


int main()
{
    cin>>m>>n;
    string line;
    getline(cin, line); // 读掉回车
    
    while(m--){
        getline(cin, line);
        stringstream ssin(line);
        int cnt=0;
        int p;
        
        while(ssin >>p) stop[cnt++]=p; // 第cnt个站牌是p
        for(int j=0;j<cnt;++j)
            for(int k=j+1; k<cnt;++k)
                g[stop[j]][stop[k]]=true;
        
    }
    
    bfs();
    
    if(dis[n] == 0x3f3f3f3f) puts("NO");
    else  cout<<max(dis[n] - 1, 0)<<endl;
    return 0;
}



