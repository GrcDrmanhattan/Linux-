1019 / 

第一题


几乎回文串
时间限制： 1000MS
内存限制： 65536KB
题目描述：
小明同学很喜欢回文串。回文串就是从左往右读和从右往左读都一样的字符串，例如“ABCBA”或者“ABCCBA”。
基于回文串，爱思考的小明提出了“几乎回文串”。 那么，什么是几乎回文串呢？“几乎回文串”就是一个最多只需要修改1个字符就可以变成回文串的字符串。
如果一个字符串本身就是一个回文串，当然也是一个“几乎回文串”。 
例如：“ABCCDA”，虽然它不是一个回文串，但是它是一个几乎回文串，因为只需要把其中的“D”改为“B”或者把"B"改为“D”就可以构成一个回文串。 
现在有一个全部都是大写英文字母的字符串，请你编写一个程序，判断这个字符串是不是一个“几乎回文串”？



输入描述
数据中包含多组输入。 每行输入一个长度为N（1<=N<=1000）的全部由大写英文字母组成的字符串。

数据保证50%为单行输入，100%为50行之内

输出描述
对于输入数据中的每一行，如果是一个“几乎回文串”输出“Yes”，如果不是则输出“No”。


样例输入
ABCCDA
ABCCBA
ABCDCBB
ABCDE
ABBCC
样例输出
Yes
Yes
Yes
No
No


------------------------------   ac 


#include<bits/stdc++.h>

using namespace std;

bool check(string &s){
    	int i=0;
        int j=s.size()-1;
        int cnt=0;
        while(i<j){
            if(s[i] != s[j] && cnt==0){
                cnt++;
                //continue;
            }
            else if(s[i] != s[j] && cnt != 0){
                return false;
                break;
            }
            i++;
            j--;
        }
    return true;
}

int main(){
    int n=50;
    string s;
    while(cin>>s){
		
		auto res=check(s);
        if(res) cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    
    
    return 0;
}



第二题  


两个集合
时间限制： 1000MS
内存限制： 65536KB
题目描述：
现在有两个分别包含M和N个整数的集合S1和S2。S1中的元素互不相同，S2中的元素也互不相同。 给定一个整数K，然后从S1和S2中各选取一个整数，使得其和等于K。
请问一共存在多少种不同的选取方案？ 从S1中选取A、从S2中选取B与从S1中选取B、从S2中选取A是两种不同的选取方案。如果一种选取方案都不存在，则输出0。



输入描述
单组输入。 第1行输入三个整数M、N和K，其中，M和N均不超过10000。 第2行输入M个不同的整数，对应集合S1中的M个元素。 第3行输入N个不同的整数，对应集合S2中的N个元素。

数字间两两均有空格隔开

输出描述
输出不同选取方案的数量；如果一种选取方案都不存在，则输出0。


样例输入
3 4 0
-1 1 2
-2 1 -1 0
样例输出
3



#############   ac36


#include<bits/stdc++.h>

using namespace std;

int main(){
    int n, m, k;
    cin>>m>>n>>k;
    vector<int> v1, v2;
    for(int i=0;i<m;++i) {
        int x;
        cin>>x;
        v1.push_back(x);
    }
    
    for(int i=0;i<n;++i){
        int x;cin>>x;
        v2.push_back(x);
	}
    
    int res=0;
    sort(v1.begin(), v1.end());
    sort(v2.begin() , v2.end());
    
    for(int i=0;i<m;++i){
        int a=v1[i];
        int l=0;
        int r=n-1;
        while(l<r){
            int mid=l+r+1>>1;
            if(a + v2[mid] <= k) {
                l=mid;
                if(a + v2[mid] == k) res++;
            }
            else r=mid-1;
        }
    }
    
    cout<<res<<endl;
    
    return 0;
}



