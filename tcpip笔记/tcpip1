tcpip 编程笔记
服务器端
1.接受连接请求 的一端 
主要包括，socket函数创建套接字
	      bind函数分配IP地址端口号，命名socket
	   listen函数转为可接受状态，等待连接请求，创建一个监听队列存放待处理
              accept函数 可以接受别人的连接请求(为了接受信息，自动创建套接字,通过返回的sockt和被接受连接的客户端通信，只是从监听队列取出连接不管连接状态和网络状况
客户端client
1.	socket函数 
	connect函数向服务器发送连接请求，客户端通过返回的这个和服务器通信
面向连接tcp： 无数据边界：发送和接收 次数不一定对应
面向消息udp套接字：有数据边界：接受传输次数相同

IP层 
是面向消息，不可靠协议，会选择数据传输路径，但不处理数据错误
IP层只关注一个数据包传输过程，传输顺序和传输本身不可靠
tcp向不可靠的ip协议提供可靠性，

fork 函数
父进程调用fork，父进程的pid存有子进程ID，子进程的id为空
广播是只向在同一网络主机传输数据
多播是跨越不同网络的的传输数据
select 函数适用于大多数操作系统，epoll只在Linux 下支持


临界区通常位于线程运行的函数内部，

http 服务器端
1 。客户端请求信息 
	get 用于请求数据 ，post。用于 传输数据
数组指针 ： 行指针，意思是指针指向一个数组，
指针数组： 多个指针变量，数组里存放的是一个个的指针，占有多个指针的存储空间，
使用&引用作为函数的参数是对实参直接操作。
大根端是低地址存放最高有效字节，最高有效字节是从左到右，低地址是从左到右，
几乎所有所有的网络协议是大根端传输数据

2.struct 成员默认访问权限是public，class则是private
3 静态数据成员和静态成员函数属于类的部分，不属于对象，
静态成员函数没有this指针，所以不能访问本类中的非静态成员，cpp中静态成员函数主要用来访问静态成员
4cpp中每个空类的实例占一个字节空间，成员函数，构造函数、析构函数不占空间，虚函数会占空间，因为为了支持虚函数表
5 this指针是当前被调用函数所在对象的起始地址；
6 为了统一，编译，链接cpp都使用g++了，因为，gcc不能自动和cpp使用的库进行链接，造成错觉cpp只能用g++，
7 -c 表示把g++ 只把文件编译成目标文件，后缀为“.o”, 
linux 内存分配：
1.堆是从下到上扩展的数据结构，不连续的内存区域，程序员控制；
2.栈是从上到下的扩展，连续的内存，栈的最大容量是系统预先设定好的，由系统自动分配。
3 全局变量是静态存储，在编译时就分配了存储空间，
函数内局部变量是栈上分配，


五层网络模型：
应用层：http，ftp，
运输层： 主机间不同进程的通信，tcp。udp，数据段，
网络层：不同主机间通信，数据包
数据链路层：将网络层ip数据报组装成帧，arp，帧
物理层：透明传输比特流
tcp链接是全双工的，可以同时发送和接收。
结构化数据：二维表结构
非结构化：杂乱无章，很难用一个概念，文档、图片、
多线程是在同一进程空间存在多个栈，每一个栈对应一个线程
子线程通过pthread_exit 传递一个返回值，主线程通过pthread_join获得返回值，判断正常退出与否
linux 进程:代码段，数据段，堆栈段
代码段：存放程序代码数据
数据段：程序的全局变量，常量，静态变量
堆栈段：函数参数，函数内部定义局部变量，进程控制pcb
子进程复制了父进程的数据段和堆栈段，共享代码段，由于复制了堆栈，所以两个都停留在fork函数,所以fok会返回两次，一次是在父进程返回，一个在子进程返回，但返回值不同
1 exit函数是在_exit()函数之上的一个封装，会自动调用exit，并且调用前刷新流数据，他们最大区别在于exit函数调用之前，系统需要检查文件的打开情况，将文件缓冲区内容写回文件。
孤儿进程：父进程退出后，但子进程还在运行。将被init进程进程号为1所收养，
僵尸进程：父进程未退出，但子进程退出，子进程的进程描述符仍在系统中，父进程没有获取子进程的状态信息
位运算判断奇偶数：&1 结果为真是奇数，为假是偶数
http不管回应报文还是请求报文，都为：报文头、0个多个请求头、空行结束请求头、可选消息体
http返回码

sudo su只是获取root权限，不是root用户登录。正确的命令应该是sudo -i或sudo su -

inetaddr函数将点分十进制可读性好的ip地址转移为二进制IP地址(网络字节序表示
inetaton相同上功能，但会把结果存储参数指向的地址结构
inet_ntoa将网络字节序表示即二进制地址转换为可读性好的IP地址即：点分十进制
inet_pton将十进制IP地址转换为二进制地址
inet_ntop以上功能相反，将二进制地址转换为点分十进制地址
pipe函数，参数fd[1]写数据，fd[0]读出数据






————————————面经答案
1.C++从源文件到可执行文件的过程、目标文件里面是什么？什么结构？链接是什么？静态链接、动态链接是什么，它们具体做了什么


	预处理-编译-汇编-链接
目标文件(.o): 源代码经过编译形成，目标文件和库链接形成可执行文件，库其实是一组目标文件的包，目标文件从结构上讲是编译后的可执行文件格式，只不过没有进行链接，有些符号或者地址没有进行校正，目标文件就是源代码编译后但未进行链接的中间文件，
目标文件格式：在Linux下可执行文件叫ELF,Windows下叫PE，在Mac系列下，通常是mach o格式文件
链接是把代目独立编译后，进行组装，包括了地址空间分配，重定位等
静态链接：对函数库的链接，是放在编译时期完成是静态链接，
动态链接：可以把一些库函数的链接载入推迟到程序运行时期这就是动态链接技术，
动态链接有利于进程间资源共享，运行的程序共享相同的代码，而静态，则是如果用到某个静态链接库时就要把库函数拷贝到自己的代码段，
动态链接可以使程序升级简单，只要动态库接口没有变，就可以用重新生成的库替换，但静态库如果库发生变化，使用库的程序就要重新编译，
静态库在编译时，就将库装载到程序中，动态库在运行才被装载，所以使用静态库更快，
2.举例说一些编译期间的错误、链接期间的错误
3.虚函数的具体实现？结合内存分布。有对象的情况下呢
